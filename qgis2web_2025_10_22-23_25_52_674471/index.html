<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
    <link rel="stylesheet" href="css/leaflet.css">
    <link rel="stylesheet" href="css/L.Control.Layers.Tree.css">
    <link rel="stylesheet" href="css/qgis2web.css">
    <link rel="stylesheet" href="css/fontawesome-all.min.css">
    <link rel="stylesheet" href="css/leaflet-search.css">
    <link rel="stylesheet" href="css/leaflet.photon.css">
    <link rel="stylesheet" href="css/leaflet-measure.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
<style>
        /* Styles de base de la carte (existants) */
        html, body { height:100%; margin:0; }
        #map { width:100%; height:100%; }

        /* Stabilité de la légende (existante) */
        .info.legend {
            z-index: 1000;
        }
        
        /* Styles du Chatbot (nouveaux styles) */
        #chat-container { 
            position: fixed; /* Rendre le conteneur fixe */
            bottom: 20px; 
            right: 20px;
            width: 300px; 
            background: white; 
            border: 1px solid #ccc; 
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 9999; /* Toujours au-dessus de tout */
            display: flex;
            flex-direction: column;
            max-height: 400px;
        }
        #chat-header {
            padding: 10px;
            background-color: #007bff;
            color: white;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            font-weight: bold;
            cursor: pointer;
        }
        #chat-body {
            flex-grow: 1;
            padding: 10px;
            overflow-y: auto;
            border-bottom: 1px solid #eee;
        }
        #chat-form {
            display: flex;
            padding: 10px;
            border-top: 1px solid #eee;
        }
        #chat-input {
            flex-grow: 1;
            padding: 8px;
            margin-right: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #chat-form button {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .user-message {
            text-align: right;
            margin-bottom: 5px;
        }
        .ai-response {
            text-align: left;
            background-color: #f1f1f1;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 5px;
        }
    </style>
    <style>
        /* Styles de base de la carte */
        html, body { height:100%; margin:0; }
        #map { width:100%; height:100%; }

        /* Stabilité de la légende (gérée par JS) */
        .info.legend {
            z-index: 1000;
        }
        
        /* Stabilité du Chatbot */
        #chat-container { 
            z-index: 9998 !important; 
            bottom: 20px; 
            right: 20px;
        }
        
        /* Stabilité du Filtre centré (si des éléments externes le recouvrent) */
        #filter-controls {
            z-index: 9999;
        }
    </style>
    <title>Carte interactive QGIS2Web</title>
</head>
<body>

<div id="map"></div>
<div id="chat-container">
        <div id="chat-header">Assistant IA Gémini</div>
        <div id="chat-body">
            <p class="ai-response">Bonjour ! Je suis l'assistant IA propulsé par Gemini. Posez-moi une question sur la carte ou sur l'archéologie.</p>
        </div>
        <form id="chat-form">
            <input type="text" id="chat-input" placeholder="Votre message..." required>
            <button type="submit">Envoyer</button>
        </form>
</div>
<div id="filter-controls" style="
    position: absolute; 
    top: 10px; 
    left: 70px; /* À côté des boutons de zoom */
    z-index: 9999; 
    background: rgba(255, 255, 255, 0.9); 
    padding: 10px; 
    border-radius: 5px; 
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    font-family: Arial, sans-serif;
">
    <select id="filterPhase" onchange="filterVestiges()">
    <option value="Tous">Toutes les Phases</option>
    </select>

<select id="filterType" onchange="filterVestiges()">
    <option value="Tous">Tous les Types</option>
    </select>

    <div id="vestiges-count" style="margin-top: 10px; font-size: 11px;"></div>
	<button id="downloadShpBtn" style="
    margin-top:10px;
    background:#0078ff;
    color:white;
    border:none;
    border-radius:4px;
    padding:6px 10px;
    cursor:pointer;
">
    ⬇️ Télécharger la carte en Geojson
</button>
<button id="ceramicCountBtn" style="
    margin-top:10px;
    background:#E91E63; /* Couleur Céramique */
    color:white;
    border:none;
    border-radius:4px;
    padding:6px 10px;
    cursor:pointer;
    display: block;
    width: 100%;
">
    &#x1F3FA; Afficher Céramiques par Fait
</button>
</div>
<div id="ceramic-results-container" style="
    position: absolute; 
    top: 10px; /* Aligné en haut de la carte */
    left: 310px; /* Décalé à droite des contrôles de filtre */
    z-index: 9999; 
    background: rgba(255, 255, 255, 0.95); 
    padding: 10px; 
    border-radius: 5px; 
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    font-family: Arial, sans-serif;
    max-height: 400px;
    overflow-y: auto;
    width: 250px;
    display: none; /* Masqué par défaut */
">
    <h4 style="margin: 0 0 10px 0;">&#x1F3FA; Totaux Céramiques par Critère</h4>
    <div id="ceramic-results-content">
        </div>
</div>
<div id="legend-content" style="
    /* ⚠️ Ces styles sont pour l'apparence, la position est gérée par le JS de Leaflet */
    background: white; 
    padding: 8px; 
    border-radius: 5px; 
    box-shadow: 0 1px 5px rgba(0,0,0,0.4); 
    font-family: sans-serif; 
    font-size: 12px;
    display: none; /* Masqué car le contrôle Leaflet va le copier/afficher */
">
    <b>Légende des Phases :</b>
    
    <div>
        <span style="background: rgba(0, 191, 255, 0.7); border: 1px solid rgba(0, 100, 150, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Néolithique (Cyan)
    </div>
    
    <div>
        <span style="background: rgba(128, 0, 128, 0.7); border: 1px solid rgba(64, 0, 64, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Protohistoire (Violet)
    </div>
    
    <div>
        <span style="background: rgba(255, 0, 0, 0.7); border: 1px solid rgba(150, 0, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Antiquité (Rouge)
    </div>
    
    <div>
        <span style="background: rgba(144, 238, 144, 0.7); border: 1px solid rgba(0, 100, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Médiéval (Vert clair)
    </div>
    
    <div>
        <span style="background: rgba(255, 255, 153, 0.7); border: 1px solid rgba(200, 200, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Moderne (Jaune clair)
    </div>
    
    <div>
        <span style="background: rgba(255, 140, 0, 0.7); border: 1px solid rgba(150, 80, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Contemporain (Orange)
    </div>
    
    <div>
        <span style="background: rgba(50, 50, 50, 0.9); border: 1px solid rgba(0, 0, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Indéterminé (Noir)
    </div>
    <div>
        <span style="background: rgba(177, 177, 177, 0.5); border: 1px solid rgba(100, 100, 100, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Aucun renseignement (Gris)
    </div>
</div>

<!-- Scripts de base -->
<script src="js/qgis2web_expressions.js"></script>
<script src="js/leaflet.js"></script>
<script src="js/L.Control.Layers.Tree.min.js"></script>
<script src="js/leaflet.rotatedMarker.js"></script>
<script src="js/leaflet.pattern.js"></script>
<script src="js/leaflet-hash.js"></script>
<script src="js/Autolinker.min.js"></script>
<script src="js/rbush.min.js"></script>
<script src="js/labelgun.min.js"></script>
<script src="js/labels.js"></script>
<script src="js/leaflet.photon.js"></script>
<script src="js/leaflet-measure.js"></script>
<script src="js/leaflet-search.js"></script>
<script src="data/Emprise_0.js"></script>
<script src="data/Cadastre_1.js"></script>
<script src="data/Vestiges_2.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://unpkg.com/@mapbox/shp-write@latest/shpwrite.js"></script>

    <script>
// --- INITIALISATION DE LA CARTE ---
var map = L.map('map', {
    zoomControl: false,
    maxZoom: 28,
    minZoom: 1
}).fitBounds([[44.7773913006228,4.819553954184861],[44.77947941499905,4.826186775095028]]);


// ✅ CORRECTION MAJEURE: Empêcher le conteneur de filtre personnalisé de bloquer les clics
var filterControls = document.getElementById('filter-controls');
if (filterControls) {
    // Ceci permet aux clics d'atteindre les contrôles Leaflet sous le panneau de filtre.
    L.DomEvent.disableClickPropagation(filterControls);
    L.DomEvent.disableScrollPropagation(filterControls); 
    console.log("Propagation des événements désactivée pour #filter-controls.");
}

// --- Code de Contrôle Leaflet pour la Légende (RÉVISÉ) ---

// 1. Définir le contrôle personnalisé
	var legendControl = L.control({
    position: 'topright' // ✅ Positionne la légende en haut à droite
});

// 2. Méthode pour obtenir le contenu du contrôle
legendControl.onAdd = function (map) {
    // Crée un NOUVEAU conteneur div pour le contrôle (classe standard Leaflet)
    var div = L.DomUtil.create('div', 'info legend'); 
    
    // Récupère le contenu HTML de l'élément existant (#legend-content)
    var contentElement = document.getElementById('legend-content');

    // 🛑 S'assurer que l'élément existe avant de continuer
    if (contentElement) {
        // Copie le contenu HTML dans le nouveau conteneur Leaflet
        div.innerHTML = contentElement.innerHTML;
        
        // Optionnel : Cacher l'élément HTML original maintenant qu'il est copié dans le contrôle
        contentElement.style.display = 'none'; 
    } else {
        div.innerHTML = 'Légende introuvable.';
    }

    // Assurez-vous que le conteneur du contrôle ne propage pas les clics à la carte
    L.DomEvent.disableClickPropagation(div);

    // Retourner le nouveau conteneur géré par Leaflet
    return div;
};

// 3. Ajouter le contrôle à la carte
map.addControl(legendControl);

// --- Fin du Code de Contrôle RÉVISÉ ---

// --- Hash URL ---
var hash = new L.Hash(map);

// --- Attribution (Correction point m&eacute;dian et accents) ---
map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');

// --- Autolinker ---
var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});

// --- Contr&ocirc;les ---
var zoomControl = L.control.zoom({ position: 'topleft' }).addTo(map);
var measureControl = new L.Control.Measure({
    position: 'topleft',
    primaryLengthUnit: 'meters',
    secondaryLengthUnit: 'kilometers',
    primaryAreaUnit: 'sqmeters',
    secondaryAreaUnit: 'hectares'
}).addTo(map);
document.getElementsByClassName('leaflet-control-measure-toggle')[0].innerHTML = '';
document.getElementsByClassName('leaflet-control-measure-toggle')[0].className += ' fas fa-ruler';

// --- &Eacute;CHELLE GRAPHIQUE DYNAMIQUE ---
var scaleBar = L.control({position: 'bottomleft'});

scaleBar.onAdd = function(map) {
    var div = L.DomUtil.create('div', 'custom-scale-bar');
    div.innerHTML = `
      <div class="scale-bar-container">
        <div class="scale-segment black"></div>
        <div class="scale-segment white"></div>
        <div class="scale-segment black"></div>
        <span class="scale-label">0 m</span>
      </div>
    `;
    return div;
};

scaleBar.addTo(map);

// --- STYLE VISUEL ---
var scaleBarStyle = document.createElement('style');
scaleBarStyle.innerHTML = `
.custom-scale-bar {
  position: relative;
  width: 100px;
  height: 10px;
  margin: 8px;
  user-select: none;
}
.scale-bar-container {
  display: flex;
  align-items: center;
}
.scale-segment {
  flex: 1;
  height: 8px;
  border: 1px solid #333;
}
.scale-segment.black {
  background: #000;
}
.scale-segment.white {
  background: #fff;
}
.scale-label {
  margin-left: 6px;
  font-size: 11px;
  color: #222;
  font-family: 'Segoe UI', Roboto, sans-serif;
}
`;
document.head.appendChild(scaleBarStyle);

// --- LOGIQUE DYNAMIQUE DE MISE &Agrave; JOUR ---
function updateScaleBar() {
    // largeur de r&eacute;f&eacute;rence en pixels
    var maxBarWidthPx = 100;
    var center = map.getCenter();
    
    // calcul de la distance r&eacute;elle repr&eacute;sent&eacute;e par la barre (m&egrave;tres)
    var pointA = map.containerPointToLatLng([0, map.getSize().y / 2]);
    var pointB = map.containerPointToLatLng([maxBarWidthPx, map.getSize().y / 2]);
    var distanceMeters = map.distance(pointA, pointB);

    // arrondir la valeur &agrave; une &eacute;chelle cartographique "jolie"
    var niceValues = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000];
    var displayValue = niceValues[0];
    for (var i = 0; i < niceValues.length; i++) {
        if (distanceMeters / niceValues[i] < 2) {
            displayValue = niceValues[i];
            break;
        }
    }

    // calcul de la largeur r&eacute;elle en pixels pour cette distance
    var displayWidth = maxBarWidthPx * (displayValue / distanceMeters);

    // mise &agrave; jour visuelle
    var scaleDiv = document.querySelector('.custom-scale-bar');
    if (scaleDiv) {
        var container = scaleDiv.querySelector('.scale-bar-container');
        container.style.width = displayWidth + 'px';
        scaleDiv.querySelector('.scale-label').textContent =
            displayValue >= 1000 ? (displayValue / 1000) + ' km' : displayValue + ' m';
    }
}

// --- METTRE &Agrave; JOUR &Agrave; CHAQUE ZOOM OU D&Eacute;PLACEMENT ---
map.on('zoomend moveend', updateScaleBar);
map.whenReady(updateScaleBar);

    // --- Fonctions popup (Mise &agrave; jour pour affichage lisible) ---
    function removeEmptyRowsFromPopupContent(content, feature) {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        var rows = tempDiv.querySelectorAll('tr');
        for (var i = 0; i < rows.length; i++) {
            var td = rows[i].querySelector('td.visible-with-data');
            var key = td ? td.id : '';
            if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                rows[i].parentNode.removeChild(rows[i]);
            }
        }
        return tempDiv.innerHTML;
    }

    function addClassToPopupIfMedia(content, popup) {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        var imgTd = tempDiv.querySelector('td img');
        if (imgTd) {
            var src = imgTd.getAttribute('src');
            if (/\.(jpg|jpeg|png|gif|bmp|webp|avif)$/i.test(src)) {
                popup._contentNode.classList.add('media');
                setTimeout(function() { popup.update(); }, 10);
            } else if (/\.(mp3|wav|ogg|aac)$/i.test(src)) {
                var audio = document.createElement('audio');
                audio.controls = true;
                audio.src = src;
                imgTd.parentNode.replaceChild(audio, imgTd);
                popup._contentNode.classList.add('media');
                setTimeout(function() {
                    popup.setContent(tempDiv.innerHTML);
                    popup.update();
                }, 10);
            } else if (/\.(mp4|webm|ogg|mov)$/i.test(src)) {
                var video = document.createElement('video');
                video.controls = true;
                video.src = src;
                video.style.width = "400px";
                video.style.height = "300px";
                video.style.maxHeight = "60vh";
                video.style.maxWidth = "60vw";
                imgTd.parentNode.replaceChild(video, imgTd);
                popup._contentNode.classList.add('media');
                video.addEventListener('loadedmetadata', function() {
                    popup.update();
                });
                setTimeout(function() {
                    popup.setContent(tempDiv.innerHTML);
                    popup.update();
                }, 10);
            } else {
                popup._contentNode.classList.remove('media');
            }
        } else {
            popup._contentNode.classList.remove('media');
        }
    }

    

    var bounds_group = new L.featureGroup([]);
    function setBounds() {}

// --- Emprise ---
    function pop_Emprise_0(feature, layer) {
        var popupContent = '<table>\
            <tr><th>QC_ID</th><td>' + (feature.properties['qc_id'] != null ? Autolinker.link(feature.properties['qc_id'].toString()) : '') + '</td></tr>\
            <tr><th>ID</th><td>' + (feature.properties['id'] != null ? Autolinker.link(feature.properties['id'].toString()) : '') + '</td></tr>\
        </table>';
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on('popupopen', function(e) { addClassToPopupIfMedia(content, e.popup); });
        layer.bindPopup(content, { maxHeight: 400 });
    }

    function style_Emprise_0_0() {
        return {
            pane: 'pane_Emprise_0',
            opacity: 1,
            color: 'rgba(35,35,35,1.0)',
            weight: 1.0,
            fill: true,
            fillOpacity: 1,
            fillColor: 'rgba(0,0,255,0.0)',
            interactive: true,
        }
    }

    map.createPane('pane_Emprise_0');
    map.getPane('pane_Emprise_0').style.zIndex = 400;
    var layer_Emprise_0 = new L.geoJson(json_Emprise_0, {
        onEachFeature: pop_Emprise_0,
        style: style_Emprise_0_0,
        pane: 'pane_Emprise_0',
    });
    bounds_group.addLayer(layer_Emprise_0);
    map.addLayer(layer_Emprise_0);


    // --- Cadastre ---
    function pop_Cadastre_1(feature, layer) {
        var popupContent = '<table>\
            <tr><th>NUM&Eacute;RO</th><td>' + (feature.properties['numero'] != null ? Autolinker.link(feature.properties['numero'].toString()) : '') + '</td></tr>\
        </table>';
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on('popupopen', function(e) { addClassToPopupIfMedia(content, e.popup); });
        layer.bindPopup(content, { maxHeight: 400 });
    }

    function style_Cadastre_1_0() {
        return {
            pane: 'pane_Cadastre_1',
            opacity: 1,
            color: 'rgba(227,26,28,1.0)',
            weight: 1.0,
            fill: true,
            fillOpacity: 1,
            fillColor: 'rgba(243,166,178,0.0)',
            interactive: true,
        }
    }

    map.createPane('pane_Cadastre_1');
    map.getPane('pane_Cadastre_1').style.zIndex = 401;
    var layer_Cadastre_1 = new L.geoJson(json_Cadastre_1, {
        onEachFeature: pop_Cadastre_1,
        style: style_Cadastre_1_0,
        pane: 'pane_Cadastre_1',
    });
    bounds_group.addLayer(layer_Cadastre_1);
    map.addLayer(layer_Cadastre_1);

    // --- Vestiges ---
    function pop_Vestiges_2(feature, layer) {
        var popupContent = '<table>\
            <tr><th>FAIT</th><td>' + (feature.properties['fait'] != null ? Autolinker.link(feature.properties['fait'].toString()) : '') + '</td></tr>\
            <tr><th>PHASE</th><td>' + (feature.properties['Phase'] != null ? Autolinker.link(feature.properties['Phase'].toString()) : '') + '</td></tr>\
            <tr><th>TYPE</th><td>' + (feature.properties['Type'] != null ? Autolinker.link(feature.properties['Type'].toString()) : '') + '</td></td></tr>\
			<tr><th>MOBILIER C</th><td>' + (feature.properties['Mobilier C'] != null ? Autolinker.link(feature.properties['Mobilier C'].toString()) : '') + '</td></td></tr>\
			<tr><th>MOBILIER F</th><td>' + (feature.properties['Mobilier F'] != null ? Autolinker.link(feature.properties['Mobilier F'].toString()) : '') + '</td></td></tr>\
        </table>';
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on('popupopen', function(e) { addClassToPopupIfMedia(content, e.popup); });
        layer.bindPopup(content, { maxHeight: 400 });
    }

   // --- Vestiges : Fonction de style modifiée pour la couleur thématique (Ordonnée Chronologiquement) ---
function style_Vestiges_2_0(feature) {
    let phase = feature.properties.Phase ? String(feature.properties.Phase).toLowerCase().trim() : 'aucun renseignement';
    let fillColor;
    let color;
    let weight = 1.5;
    let fillOpacity = 0.7;

    // Définition des couleurs par phase (Chronologie: Néolithique -> Contemporain)
    switch (phase) {
        // >>> 1. Néolithique (Cyan) <<<
        case 'néolithique':
        case 'neolithique': 
            // Cyan pour le Néolithique
            fillColor = 'rgba(0, 191, 255, 0.7)'; // Deep Sky Blue
            color = 'rgba(0, 100, 150, 1.0)';
            break;
        
        // >>> 2. Protohistoire (Violet) <<<
        case 'protohistoire':
            // Violet pour la Protohistoire
            fillColor = 'rgba(128, 0, 128, 0.7)'; // Purple
            color = 'rgba(64, 0, 64, 1.0)';
            break;

        // >>> 3. Antiquité (Rouge) <<<
        case 'antiquité':
            // Rouge pour l'Antiquité
            fillColor = 'rgba(255, 0, 0, 0.7)';
            color = 'rgba(150, 0, 0, 1.0)';
            break;

        // >>> 4. Médiéval (Vert clair) <<<
        case 'médiéval':
            // Vert clair pour le Médiéval
            fillColor = 'rgba(144, 238, 144, 0.7)'; // LightGreen
            color = 'rgba(0, 100, 0, 1.0)';
            break;

        // >>> 5. Moderne (Jaune clair) <<<
        case 'moderne':
            // Jaune clair pour le Moderne
            fillColor = 'rgba(255, 255, 153, 0.7)'; // LightYellow
            color = 'rgba(200, 200, 0, 1.0)';
            break;

        // >>> 6. Contemporain (Orange) <<<
        case 'contemporain':
            // Orange foncé pour le Contemporain
            fillColor = 'rgba(255, 140, 0, 0.7)'; // Dark Orange
            color = 'rgba(150, 80, 0, 1.0)';
            break;
        
        // --- Cas Spéciaux (Indéterminé/Inconnu) ---
        case 'indetermine':
        case 'indéterminé': // Gestion des accents
            // Noir pour Indéterminé
            fillColor = 'rgba(50, 50, 50, 0.9)'; 
            color = 'rgba(0, 0, 0, 1.0)';
            fillOpacity = 0.9;
            break;
        default:
            // Gris pour 'Aucun renseignement' / Inconnu
            fillColor = 'rgba(177, 177, 177, 0.5)';
            color = 'rgba(100, 100, 100, 1.0)';
            weight = 1.0;
            fillOpacity = 0.5;
    }

    return {
        pane: 'pane_Vestiges_2',
        opacity: 1,
        color: color,
        weight: weight,
        fill: true,
        fillOpacity: fillOpacity,
        fillColor: fillColor,
        interactive: true,
    }
}

    map.createPane('pane_Vestiges_2');
    map.getPane('pane_Vestiges_2').style.zIndex = 402;
    var layer_Vestiges_2 = new L.geoJson(json_Vestiges_2, {
        onEachFeature: pop_Vestiges_2,
        style: style_Vestiges_2_0,
        pane: 'pane_Vestiges_2',
    });
    bounds_group.addLayer(layer_Vestiges_2);
    map.addLayer(layer_Vestiges_2);

    // --- Labels et recherche ---
    var i = 0;
    layer_Vestiges_2.eachLayer(function(layer) {
        layer.bindTooltip((layer.feature.properties['fait'] ? 
            '<div style="color: #323232; font-size: 5pt; font-weight: bold; font-style: italic; font-family: Times New Roman, sans-serif;">' + 
            layer.feature.properties['fait'] + '</div>' : ''), 
            {permanent: true, offset: [0, -16], className: 'css_Vestiges_2'});
        labels.push(layer);
        totalMarkers += 1;
        layer.added = true;
        addLabel(layer, i);
        i++;
    });

    map.addControl(new L.Control.Search({
        layer: layer_Vestiges_2,
        initial: false,
        hideMarkerOnCollapse: true,
        propertyName: 'fait'
    }));

    if (typeof url === 'undefined') {
        document.getElementsByClassName('search-button')[0].className += ' fa fa-binoculars';
    } else {
        document.getElementsByClassName('search-button')[1].className += ' fa fa-binoculars';
    }

    map.on("zoomend", function(){
    resetLabels([window.layer_Vestiges_2_Filtered || layer_Vestiges_2]);
});
    </script>
    
    <script>
// --- AJOUT DU CONTRÔLE DE DESSIN ET DES ATTRIBUTS ---

// 1. Créer un groupe de calques pour stocker les éléments dessinés
var drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

// 2. Configurer le contrôle de dessin
var drawControl = new L.Control.Draw({
    // ✅ Positionnement en bas à gauche
    position: 'topleft', 
    edit: {
        featureGroup: drawnItems, // Permet d'éditer/supprimer les éléments dessinés
        remove: true
    },
    draw: {
        polygon: {
            allowIntersection: false, 
            showArea: true 
        },
        // Seul le polygone est activé selon votre configuration
        polyline: false, 
        circle: false,   
        marker: false,   
        rectangle: false, 
        circlemarker: false  
    }
});

// 💥 AJOUTER LE CONTRÔLE À LA CARTE
map.addControl(drawControl); 

// 3. Gérer l'événement de création d'un élément
map.on(L.Draw.Event.CREATED, function (e) {
    var type = e.layerType,
        layer = e.layer;

    if (type === 'polygon') {
        
        // --- Collecte des rubriques (attributs) via des boîtes de dialogue ---
        var faitVal = prompt("Entrez la valeur pour 'FAIT' (ex: F99) :");
        if (faitVal === null || faitVal.trim() === "") {
            // Annuler si l'utilisateur ne donne pas de nom de Fait
            return;
        }

        var phaseVal = prompt("Entrez la valeur pour 'PHASE' (ex: antiquité, médiéval, inconnue) :");
        var typeVal = prompt("Entrez la valeur pour 'TYPE' (ex: Mur, Sol, Fosse) :");
        var mobilierCVal = prompt("Entrez la valeur pour 'MOBILIER C' (ex: 30,26,45) :");
        var mobilierFVal = prompt("Entrez la valeur pour 'MOBILIER F' (ex: 25,89,78) :");
        
        // 4. Créer la structure GeoJSON avec les nouvelles rubriques
        var feature = layer.toGeoJSON();
        feature.properties = {
            'fait': faitVal.trim(),
            'Phase': (phaseVal || 'inconnue').trim(),
            'Type': (typeVal || 'non défini').trim(),
            'Mobilier C': (mobilierCVal || '').trim(),
            'Mobilier F': (mobilierFVal || '').trim()
        };

        // 5. Créer une nouvelle couche Leaflet à partir du GeoJSON pour styliser et ajouter le popup
        var newLayer = L.geoJson(feature, {
            onEachFeature: function(feature, layer) {
                 // Recréer le contenu du popup avec les rubriques saisies
                 var popupContent = '<table>\
                    <tr><th>FAIT</th><td>' + feature.properties['fait'] + '</td></tr>\
                    <tr><th>PHASE</th><td>' + feature.properties['Phase'] + '</td></tr>\
                    <tr><th>TYPE</th><td>' + feature.properties['Type'] + '</td></td></tr>\
                    <tr><th>MOBILIER C</th><td>' + feature.properties['Mobilier C'] + '</td></td></tr>\
                    <tr><th>MOBILIER F</th><td>' + feature.properties['Mobilier F'] + '</td></td></tr>\
                 </table>';
                 layer.bindPopup(popupContent, { maxHeight: 400 });
                 
                 // Appliquer un style visuel simple pour différencier les éléments dessinés
                 layer.setStyle({
                     // 1. Bordure : Noir ou Gris foncé uni (opacité 1.0)
                     color: '#000000', // Noir, ou 'rgba(0, 0, 0, 1.0)' si vous préférez
                     weight: 3, 
                     opacity: 1.0, 
                     
                     // 2. Remplissage : Gris foncé (opacité 0.7 à 0.9 pour qu'il soit transparent)
                     fillColor: '#323232', // Équivalent de rgba(50, 50, 50, 0.9)
                     fillOpacity: 0.7 // Une opacité plus faible pour le remplissage (0.7)
                 });
            }
        });

        // 6. Ajouter les éléments dessinés au groupe (ils deviennent visibles et éditables)
        newLayer.eachLayer(function(l) {
            drawnItems.addLayer(l);
        });
        
        console.log("Nouveau polygone dessiné et attributs enregistrés.", feature.properties);
    }
});
    </script>
    
    <script>
    (function(){
        // --- Dictionnaire corrig&eacute; ---
        var layerLookup = {
            "Cadastre": layer_Cadastre_1,
            "Vestiges": layer_Vestiges_2
        };

        function normalizeStr(s){
            if (s === null || s === undefined) return "";
            return String(s).toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/\s+/g,' ').trim();
        }

        function zoomToLayerItem(layerItem){
            if (typeof layerItem.getLatLng === 'function'){
                map.setView(layerItem.getLatLng(), 22);
            } else if (typeof layerItem.getBounds === 'function'){
                map.fitBounds(layerItem.getBounds().pad(0.01), { maxZoom: 22 });
            }
            if (layerItem.openPopup) layerItem.openPopup();
        }

        function searchAllLayers(searchValue){
            var target = normalizeStr(searchValue);
            var matches = [];
            Object.keys(layerLookup).forEach(function(layerName){
                var lyr = layerLookup[layerName];
                if (!lyr) return;
                lyr.eachLayer(function(layerItem){
                    var props = (layerItem.feature && layerItem.feature.properties) || {};
                    for (var key in props){
                        if (!props.hasOwnProperty(key)) continue;
                        var val = normalizeStr(props[key]);
                        if (val && (val === target || val.indexOf(target) !== -1)){
                            matches.push({
                                layerName: layerName,
                                field: key,
                                value: props[key],
                                layerItem: layerItem
                            });
                        }
                    }
                });
            });
            return matches;
        }

        function zoomToByAnyField(searchValue){
            if (!searchValue) {
                // Correction encodage
                console.warn("Valeur vide");
                return false;
            }
            var results = searchAllLayers(searchValue);
            if (results.length === 0){
                // Correction encodage
                console.warn("Aucun r&eacute;sultat trouv&eacute; pour:", searchValue);
                return false;
            }
            // Correction encodage
            console.log("R&eacute;sultats:", results);

            if (results.length > 1){
                var group = L.featureGroup(results.map(r=>r.layerItem));
                map.fitBounds(group.getBounds().pad(0.01), { maxZoom: 22 });
                results[0].layerItem.openPopup();
            } else {
                zoomToLayerItem(results[0].layerItem);
            }
            return true;
        }

        window.zoomToByAnyField = zoomToByAnyField;

        var urlVal = new URLSearchParams(window.location.search).get("search");
        if (urlVal){
            var tries=0, poll=setInterval(function(){
                tries++;
                if (layer_Vestiges_2 && layer_Vestiges_2.getLayers().length>0){
                    clearInterval(poll);
                    zoomToByAnyField(decodeURIComponent(urlVal));
                }
                if (tries>50) clearInterval(poll);
            },200);
        }
    })();
    </script>
    <script>
// Sauvegarde de toutes les entités de la couche Vestiges
var allVestiges = layer_Vestiges_2.toGeoJSON();

// --- Normalisation et sécurisation Unicode (DÉPLACÉES POUR RÉUTILISATION) ---
// Note: Le normalize('NFC') garde les accents correctement affichés si la donnée source les a.
const normalize = str => {
    if (!str) return null;
    return String(str)
        .trim()
        .replace(/\s+/g, ' ')
        .normalize('NFC'); 
};

const capitalize = str => {
    if (!str) return '';
    const s = str.toLowerCase();
    return s.charAt(0).toUpperCase() + s.slice(1);
};

// Fonction utilitaire pour obtenir la valeur de comparaison normalisée
function getNormalizedComparisonValue(rawValue) {
    if (!rawValue) return 'N/A';
    // Cette fonction reproduit la logique utilisée pour créer la valeur de l'option dans populateFilters
    return capitalize(normalize(rawValue));
}
// =================================================================

// =================================================================
// 1. FONCTION DE REMPLISSAGE DES FILTRES (Rend les menus déroulants utilisables)
// =================================================================

function populateFilters() {
    const phaseFilter = document.getElementById('filterPhase');
    const typeFilter  = document.getElementById('filterType');

    if (!json_Vestiges_2 || !json_Vestiges_2.features) {
        console.error("Erreur : données 'json_Vestiges_2' introuvables.");
        return;
    }

    const uniquePhases = new Map();
    const uniqueTypes  = new Map();

    json_Vestiges_2.features.forEach(f => {
        // Applique la normalisation pour obtenir une clé de comparaison cohérente
        const phaseKey = normalize(f.properties.Phase); 
        const phaseValue = capitalize(phaseKey); 

        const typeKey = normalize(f.properties.Type);
        const typeValue = capitalize(typeKey);

        if (phaseKey && phaseKey !== 'null' && phaseKey !== 'undefined') {
            uniquePhases.set(phaseKey, phaseValue);
        }
        if (typeKey && typeKey !== 'null' && typeKey !== 'undefined') {
            uniqueTypes.set(typeKey, typeValue);
        }
    });

    // --- Nettoyage avant réinjection ---
    phaseFilter.innerHTML = '<option value="Tous">Toutes les Phases</option>';
    typeFilter.innerHTML  = '<option value="Tous">Tous les Types</option>';

    // --- Ajout trié et encodé correctement ---
    Array.from(uniquePhases.values()).sort((a, b) => a.localeCompare(b, 'fr')).forEach(phase => {
        const opt = document.createElement('option');
        opt.value = phase;
        opt.textContent = phase; 
        phaseFilter.appendChild(opt);
    });

    Array.from(uniqueTypes.values()).sort((a, b) => a.localeCompare(b, 'fr')).forEach(type => {
        const opt = document.createElement('option');
        opt.value = type;
        opt.textContent = type;
        typeFilter.appendChild(opt);
    });
}

// =================================================================
// 2. FONCTION DE FILTRAGE (Règle le problème d'accent par une comparaison normalisée)
// =================================================================

function filterVestiges() {
    // 2.1 Récupérer les valeurs sélectionnées dans les filtres
    const selectedPhase = document.getElementById('filterPhase').value;
    const selectedType = document.getElementById('filterType').value;
    
    // 2.2 Retirer la couche actuelle de la carte
    if (map.hasLayer(layer_Vestiges_2)) {
        map.removeLayer(layer_Vestiges_2);
    }
    
    // 2.3 Filtrer les données GeoJSON originales
    const filteredFeatures = json_Vestiges_2.features.filter(feature => {
        // --- CORRECTION CLÉ : Normaliser la valeur de la donnée source (feature) 
        // pour la faire correspondre à la valeur de l'option (selectedPhase)
        const featurePhaseNormalized = getNormalizedComparisonValue(feature.properties.Phase);
        const featureTypeNormalized  = getNormalizedComparisonValue(feature.properties.Type);
        
        // La comparaison est maintenant robuste car elle utilise la même convention
        const phaseMatch = (selectedPhase === 'Tous') || (selectedPhase === featurePhaseNormalized);
        const typeMatch  = (selectedType === 'Tous')  || (selectedType === featureTypeNormalized);
        
        return phaseMatch && typeMatch;
    });

    // 2.4 Créer un nouvel objet GeoJSON avec les entités filtrées
    const filteredGeoJSON = {
        "type": "FeatureCollection",
        "features": filteredFeatures
    };

    // 2.5 Recréer et ajouter la couche Leaflet GeoJSON filtrée

    if (window.layer_Vestiges_2_Filtered) {
        map.removeLayer(window.layer_Vestiges_2_Filtered);
    }

    window.layer_Vestiges_2_Filtered = L.geoJson(filteredGeoJSON, {
        attribution: '',
        interactive: true,
        style: style_Vestiges_2_0,
        onEachFeature: pop_Vestiges_2,
        pointToLayer: (feature, latlng) => L.circleMarker(latlng, style_Vestiges_2_0(feature))
    });

    window.layer_Vestiges_2_Filtered.addTo(map);

    // 2.7 Réinitialiser les labels
    if (typeof resetLabels === "function") {
        resetLabels([window.layer_Vestiges_2_Filtered]);
    }

    // 2.8 Mettre à jour le compteur d'entités
    const countDiv = document.getElementById('vestiges-count');
    if (countDiv) {
        countDiv.textContent = `${filteredFeatures.length} vestige(s) affiché(s)`;
    }

    console.log(`✅ ${filteredFeatures.length} entités filtrées affichées.`);
}

// =================================================================
// 3. APPEL MANQUANT (Assure le remplissage du menu au chargement)
// =================================================================

// Remplir les menus déroulants une fois que la carte et les données sont prêtes.
map.whenReady(function() {
    if (typeof json_Vestiges_2 !== 'undefined') {
        populateFilters();
    }
});
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>


<script>
// =========================================================================
// --- LOGIQUE FILEMAKER (SYNCHRONISATION UNIDIRECTIONNELLE DES ATTRIBUTS) ---
// =========================================================================
const FM_URL = '/fm';
const FM_LAYOUT = 'Modapi';
const FM_USERNAME = 'Apia';
const FM_PASSWORD = 'Apia';
const FM_KEY_FIELD = 'fait';
let FM_TOKEN = null;
const POLLING_INTERVAL = 15000; // 15 s

// --- Authentification ---
async function getFileMakerToken() {
  if (FM_TOKEN) return FM_TOKEN;
  const authHeader = 'Basic ' + btoa(`${FM_USERNAME}:${FM_PASSWORD}`);
  try {
    const response = await fetch(`${FM_URL}/sessions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': authHeader }
    });
    if (!response.ok) throw new Error(`Erreur API: ${response.status}`);
    const data = await response.json();
    FM_TOKEN = data.response.token;
    console.log("✅ Jeton FileMaker obtenu");
    return FM_TOKEN;
  } catch (e) {
    console.error("❌ Erreur d'authentification FileMaker:", e);
    return null;
  }
}

// --- Mise à jour des propriétés des entités ---
function updateFeatureProperties(currentFeature, fmRecord) {
  const f = fmRecord.fieldData;

  // Normalisation insensible à la casse
  const phaseValue = f.Phase ?? f.phase ?? f.PHASE ?? null;
  const typeValue  = f.Type  ?? f.type  ?? f.TYPE  ?? null;
 
 // 💡 Correction : Extraction des données MOBILIER C et MOBILIER F
  const mobilierCVal = f['Mobilier C'] ?? f['Mobilier_C'] ?? null; // Adapter le nom du champ FileMaker si nécessaire (ex: Mobilier_C)
  const mobilierFVal = f['Mobilier F'] ?? f['Mobilier_F'] ?? null;

  currentFeature.properties['Phase'] = phaseValue;
  currentFeature.properties['Type']  = typeValue;
  currentFeature.properties[FM_KEY_FIELD] = f[FM_KEY_FIELD];
  
  // 💡 Correction : Application des données MOBILIER C et MOBILIER F
  currentFeature.properties['Mobilier C'] = mobilierCVal;
  currentFeature.properties['Mobilier F'] = mobilierFVal;
}


// --- Synchronisation des données FileMaker vers la carte ---
async function fetchAndSyncVestiges(token) {
  if (!token) return;
  try {
    const response = await fetch(`${FM_URL}/layouts/${FM_LAYOUT}/records`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }
    });

    if (response.status === 401) {
      console.warn("⏳ Jeton expiré, reconnexion...");
      FM_TOKEN = null;
      const newToken = await getFileMakerToken();
      if (newToken) await fetchAndSyncVestiges(newToken);
      return;
    }

    if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
    const fmData = await response.json();
    const fmRecords = fmData.response.data;
    let matchCount = 0;

    // Parcours de chaque entité de la couche
layer_Vestiges_2.eachLayer(layer => {
  const currentFait = String(layer.feature.properties[FM_KEY_FIELD] || '').trim().toLowerCase();

  // Recherche tolérante : ignore casse et espaces
  const fmRecord = fmRecords.find(r =>
    String(r.fieldData[FM_KEY_FIELD] || '').trim().toLowerCase() === currentFait
  );

  if (fmRecord) {
    updateFeatureProperties(layer.feature, fmRecord);

    // Forcer la mise à jour du popup
    const updatedPopup = `
      <table>
        <tr><th>FAIT</th><td>${layer.feature.properties['fait'] ?? ''}</td></tr>
        <tr><th>PHASE</th><td>${layer.feature.properties['Phase'] ?? ''}</td></tr>
        <tr><th>TYPE</th><td>${layer.feature.properties['Type'] ?? ''}</td></tr>
		<tr><th>MOBILIER C</th><td>${layer.feature.properties['Mobilier C'] ?? ''}</td></tr>
		<tr><th>MOBILIER F</th><td>${layer.feature.properties['Mobilier F'] ?? ''}</td></tr>
      </table>`;
    layer.bindPopup(updatedPopup, { maxHeight: 400 });
    if (layer.getPopup() && layer.getPopup().isOpen()) {
      layer.getPopup().setContent(updatedPopup);
    }

    matchCount++;
  } else {
    // Diagnostic console pour comprendre les cas manquants
    if (currentFait === 'SP1033') {
      console.warn('⚠️ Aucun enregistrement FileMaker correspondant pour SP1033');
    }
  }
});


    // 🔁 Actualisation du filtre "Phase"
    window.allVestiges = layer_Vestiges_2.toGeoJSON();
    filterVestiges();

    // 1. Remplir les menus déroulants avec les valeurs uniques
populateFilters(); 

// 2. Appliquer le filtre par défaut (qui est "Toutes") et mettre à jour le compteur
filterVestiges(); 


    console.log(`✅ FileMaker: ${matchCount} entité(s) mises à jour.`);
  } catch (e) {
// ... (Fin de la fonction fetchAndSyncVestiges)
  }
}

// --- Polling stable avec verrouillage ---
let isSyncing = false;

map.whenReady(async function() {
  console.log("🔄 Démarrage du polling FileMaker stable...");

  const token = await getFileMakerToken();
  if (!token) return;

  // Première synchronisation
  await fetchAndSyncVestiges(token);

  // Intervalle régulier (sécurisé)
  setInterval(async () => {
    if (isSyncing) return;
    isSyncing = true;
    try {
      const currentToken = await getFileMakerToken();
      await fetchAndSyncVestiges(currentToken);
    } catch (e) {
      console.error("Erreur pendant la synchro périodique:", e);
    } finally {
      isSyncing = false;
    }
  }, POLLING_INTERVAL);
});
</script>
	<div id="coord-display" style="
    position:absolute; 
    bottom:10px; 
    right:400px; /* Déplacé à gauche du Chatbot */
    z-index:9999; 
    background:rgba(255,255,255,0.85); 
    padding:4px 8px; 
    border-radius:4px; 
    font-family:monospace;
    font-size:12px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
">
    Coordonnées : 
</div>

<script>
/// ... (juste après la balise </script> du chatbot)

<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
// --- DÉFINITIONS DES SYSTÈMES DE COORDONNÉES (Gardez votre code existant ici) ---
proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
proj4.defs("EPSG:3944", "+proj=lcc +lat_0=44 +lon_0=3 +lat_1=43.25 +lat_2=44.75 +x_0=1500000 +y_0=3200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
proj4.defs("EPSG:3945", "+proj=lcc +lat_0=45 +lon_0=3 +lat_1=44.25 +lat_2=45.75 +x_0=1700000 +y_0=4200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
// ---------------------------------------------------------------------------------


// --- DÉBUT DU BLOC DE COORDONNÉES DE LA SOURIS (CORRIGÉ) ---

// Variables pour le throttling : Limiter les calculs à 5 fois par seconde (toutes les 200ms)
let lastCoordUpdate = 0;
const updateInterval = 200; 

const coordDisplay = document.getElementById('coord-display'); 

// ⚠️ CORRECTION CRITIQUE : Empêcher le conteneur de coordonnées de voler les clics.
if (coordDisplay) { 
    L.DomEvent.disableClickPropagation(coordDisplay); 
    L.DomEvent.disableScrollPropagation(coordDisplay); 
}

if (typeof proj4 === 'undefined') {
    if (coordDisplay) coordDisplay.innerHTML = "Erreur: proj4 non chargé.";
} else {
    map.on('mousemove', function(e) {
        const now = Date.now();
        
        // --- LOGIQUE DE THROTTLING : N'exécute le code qu'une fois toutes les 200ms ---
        if (now - lastCoordUpdate > updateInterval) {
            lastCoordUpdate = now;

            // --- CALCULS (Maintenant limités en fréquence) ---

            // Coordonnées WGS 84 (Lat/Lon)
            const lat = e.latlng.lat.toFixed(6);
            const lon = e.latlng.lng.toFixed(6);

            // Conversion 1: Lambert 93 (EPSG:2154) - National
            const lambert93Coords = proj4('EPSG:4326', 'EPSG:2154', [e.latlng.lng, e.latlng.lat]);
            const lambert93X = lambert93Coords[0].toFixed(2);
            const lambert93Y = lambert93Coords[1].toFixed(2);
            
            // Conversion 2: Lambert CC44 (EPSG:3944) - Zone 4
            const cc44Coords = proj4('EPSG:4326', 'EPSG:3944', [e.latlng.lng, e.latlng.lat]);
            const cc44X = cc44Coords[0].toFixed(2);
            const cc44Y = cc44Coords[1].toFixed(2);
            
            // Conversion 3: Lambert CC45 (EPSG:3945) - Zone 5
            const cc45Coords = proj4('EPSG:4326', 'EPSG:3945', [e.latlng.lng, e.latlng.lat]);
            const cc45X = cc45Coords[0].toFixed(2);
            const cc45Y = cc45Coords[1].toFixed(2);

            // Mise à jour du DOM
            if (coordDisplay) {
                coordDisplay.innerHTML = `
                    <span style="font-weight:bold;">WGS 84:</span> ${lat}° N, ${lon}° E<br>
                    <span style="font-weight:bold;">Lambert 93:</span> X=${lambert93X}, Y=${lambert93Y}<br>
                    <span style="font-weight:bold;">CC44:</span> X=${cc44X}, Y=${cc44Y}<br>
                    <span style="font-weight:bold;">CC45:</span> X=${cc45X}, Y=${cc45Y}
                `;
            }
        }
    });
}
// --- FIN DU BLOC DE COORDONNÉES DE LA SOURIS (CORRIGÉ) ---
// ...
</script>


<div id="coord-display" style="
    position: absolute; 
    bottom: 25px; 
    left: 15px; 
    z-index: 9999; 
    background: rgba(255, 255, 255, 0.9); 
    padding: 5px 8px; 
    border-radius: 5px; 
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    font-family: Arial, sans-serif;
    font-size: 11px;
    line-height: 1.4;
">
    Livron, Les Renoncées Ouest
</div>
<script>
// ATTENTION : Ce code doit être placé APRÈS le chargement des librairies Leaflet et la définition de vos couches.

document.getElementById('downloadShpBtn').addEventListener('click', function() {
    let geojson;
    
    // 1. Récupération de la couche Leaflet (filtrée en priorité, sinon la principale)
    if (window.layer_Vestiges_2_Filtered) {
        geojson = window.layer_Vestiges_2_Filtered.toGeoJSON();
    } else if (window.layer_Vestiges_2) {
        geojson = window.layer_Vestiges_2.toGeoJSON();
    } else {
        alert("Erreur : La couche 'layer_Vestiges_2' ou 'layer_Vestiges_2_Filtered' n'a pas été trouvée.");
        return;
    }

    // 2. Vérification des données
    if (!geojson || !geojson.features || geojson.features.length === 0) {
        alert("Aucune entité (polygone, point, ligne) à exporter n'a été trouvée.");
        return;
    }

    // 3. Conversion de l'objet GeoJSON en chaîne de caractères
    // L'argument '2' sert à indenter le fichier pour une meilleure lisibilité.
    const geojsonString = JSON.stringify(geojson, null, 2); 
    
    // 4. Création du Blob et du lien de téléchargement
    const jsonBlob = new Blob([geojsonString], { type: 'application/json' });
    const jsonUrl = URL.createObjectURL(jsonBlob);

    const a = document.createElement('a');
    a.href = jsonUrl;
    a.download = 'export_vestiges_brut.geojson'; // Nom du fichier téléchargé
    document.body.appendChild(a);
    a.click();

    // 5. Nettoyage après le téléchargement
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(jsonUrl);
    }, 100);

    console.log(`✅ Export GeoJSON réussi avec ${geojson.features.length} entités.`);
    alert(`Export GeoJSON brut réussi. ${geojson.features.length} entités ont été téléchargées dans 'export_vestiges_brut.geojson'.`);
});
</script>

<script>
// =================================================================
// 0. Variables Globales et Utilitaires (inchangé)
// =================================================================
let ceramicCirclesLayer = null; 

/**
 * Extrait les coordonnées d'un point représentatif de la géométrie (premier sommet).
 * Fonctionne pour Polygon et MultiPolygon.
 */
function getFeatureLocation(feature) {
    if (!feature.geometry || !feature.geometry.coordinates) {
        return null;
    }
    
    let coords;
    const type = feature.geometry.type;

    if (type === 'Polygon') {
        coords = feature.geometry.coordinates[0][0]; 
    } else if (type === 'MultiPolygon') {
        coords = feature.geometry.coordinates[0][0][0];
    } else {
        coords = feature.geometry.coordinates;
    }
    
    if (coords && coords.length >= 2 && typeof coords[0] === 'number' && typeof coords[1] === 'number') {
        return [coords[1], coords[0]]; 
    }
    return null;
}

// =================================================================
// 1. Fonction principale déclenchée par le bouton (inchangé)
// =================================================================
function showCeramicQuantities() {
    const resultsContainer = document.getElementById('ceramic-results-container');
    const resultsContent = document.getElementById('ceramic-results-content');
    const btn = document.getElementById('ceramicCountBtn');
    
    if (!resultsContainer || !btn || typeof map === 'undefined') {
        console.error("Erreur critique: Un élément HTML ou l'objet Leaflet 'map' est manquant.");
        return;
    }

    if (resultsContainer.style.display === 'block') {
        resultsContainer.style.display = 'none';
        btn.textContent = '&#x1F3FA; Afficher Céramiques par Fait';
        if (ceramicCirclesLayer) {
            map.removeLayer(ceramicCirclesLayer);
            ceramicCirclesLayer = null;
        }
        return;
    }
    
    resultsContent.innerHTML = 'Chargement des données de dispersion...';
    resultsContainer.style.display = 'block';
    btn.textContent = '&#x2715; Cacher la Dispersion';

    if (typeof json_Vestiges_2 !== 'undefined' && json_Vestiges_2.features.length > 0) {
        const featuresToProcess = window.layer_Vestiges_2_Filtered 
            ? window.layer_Vestiges_2_Filtered.toGeoJSON().features
            : json_Vestiges_2.features;
        
        displayCeramicDispersion(featuresToProcess);
        
        resultsContent.innerHTML = '<p>Affichage de la dispersion par vestige. La taille de chaque cercle est proportionnelle à la quantité de céramique du vestige.</p>';
        
    } else {
        resultsContent.innerHTML = 'Erreur: Les données de Vestiges ne sont pas disponibles.';
        console.error("Erreur DATA: json_Vestiges_2 non défini ou vide. Les données GeoJSON ne sont pas chargées.");
    }
}


// =================================================================
// 3. FONCTION displayCeramicDispersion (CORRIGÉE pour le pop-up)
// =================================================================
function displayCeramicDispersion(features) {
    
    if (ceramicCirclesLayer) {
        map.removeLayer(ceramicCirclesLayer);
    }
    
    const circles = [];
    const quantities = [];
    
    // 1. Filtrer et collecter les quantités de céramique valides
    const ceramicFeatures = features.filter(feature => {
        const mobilierC = feature.properties['Mobilier C'];
        let quantity = 0;
        
        if (mobilierC) {
             if (typeof mobilierC === 'string' && mobilierC.includes(',')) {
                quantity = mobilierC.split(',').reduce((sum, val) => sum + (parseInt(val.trim()) || 0), 0);
            } else {
                quantity = parseInt(mobilierC) || 0;
            }
        }

        if (quantity > 0) {
            feature.properties._Céramique_Qty = quantity; 
            quantities.push(quantity);
            return true;
        }
        return false;
    });

    if (ceramicFeatures.length === 0) {
        document.getElementById('ceramic-results-content').innerHTML = '<p>Aucun vestige avec des quantités de céramique positive n\'a été trouvé dans le jeu de données actuel.</p>';
        return;
    }

    const maxQty = Math.max(...quantities);
    
    // 3. Création des cercles
    ceramicFeatures.forEach(feature => {
        const location = getFeatureLocation(feature); 

        if (location) {
            const quantity = feature.properties._Céramique_Qty;

            // --- NOUVEAU : Récupération des données Fait et Type ---
            // ⚠️ REMPLACEZ 'NOM_RUBRIQUE_FAIT' et 'NOM_RUBRIQUE_TYPE' par les noms exacts de vos rubriques (sensibles à la casse)
            const faitValue = feature.properties['Fait'] || feature.properties['Nom_fait'] || feature.properties['fait'] || 'N/D';
            const typeValue = feature.properties['Type'] || feature.properties['type'] || feature.properties['Nature'] || 'N/D';


            // Échelle de rayon 
            const baseRadius = 3; 
            const maxRadius = 30; 
            const radius = baseRadius + (quantity / maxQty) * (maxRadius - baseRadius);

            const popupContent = `
                **Vestige Type :** ${typeValue}<br>
                **Fait :** ${faitValue}<br>
                **Quantité Céramique :** ${quantity}
            `;
            ///  MODIFICATION CLÉ : fillOpacity et fillColor
            // ----------------------------------------------------
            const circle = L.circle(location, {
                // 'color' est la couleur de la bordure (contour)
                color: '#C2185B', // Un rose/rouge foncé pour la bordure
                
                // 'fillColor' est la couleur de remplissage (intérieur)
                fillColor: '#F06292', // Rose clair pour l'intérieur
                
                // 'fillOpacity' contrôle la transparence (0.2 = très transparent, 1.0 = opaque)
                fillOpacity: 0.35, // **OPACITÉ RÉDUITE (environ 35% d'opacité)**
                
                radius: radius, 
            }).bindPopup(popupContent);

            circles.push(circle);
        }
    });

    // 4. Ajout de la couche et ZOOM ROBUSTE (inchangé)
    if (circles.length > 0) {
        ceramicCirclesLayer = L.layerGroup(circles).addTo(map);
        
        if (typeof layer_control !== 'undefined' && layer_control.addOverlay) {
            layer_control.addOverlay(ceramicCirclesLayer, '&#x1F3FA; Dispersion Céramique');
        }
        
        if (circles.length === 1) {
            const center = circles[0].getLatLng();
            map.setView(center, 15); 
        } else {
            try {
                 map.fitBounds(ceramicCirclesLayer.getBounds(), { padding: [20, 20] });
            } catch (e) {
                console.warn("Échec de la méthode getBounds. Centrage sur le premier vestige.");
                const center = circles[0].getLatLng();
                map.setView(center, map.getZoom() || 13);
            }
        }
    }
}

// 5. Lier la fonction au bouton lors du chargement de la page (inchangé)
document.addEventListener('DOMContentLoaded', () => {
    const ceramicBtn = document.getElementById('ceramicCountBtn');
    if (ceramicBtn) {
        ceramicBtn.addEventListener('click', showCeramicQuantities);
    } else {
        console.error("Erreur de liaison: Le bouton avec l'ID 'ceramicCountBtn' n'a pas été trouvé.");
    }
});
</script>
<script>
    // CORRECTION : Utilisation de 'var' pour éviter les conflits de déclaration 
    // avec le code JS existant dans votre fichier (chatInput, chatHeader, etc.).
    var chatBody = document.getElementById('chat-body');
    var chatForm = document.getElementById('chat-form');
    var chatInput = document.getElementById('chat-input');
    
    // Déclaration des autres variables d'éléments avec 'var'
    var chatHeader = document.getElementById('chat-header');
    var chatBodyElement = document.getElementById('chat-body');
    var chatFormElement = document.getElementById('chat-form');
    
    
    // Fonction utilitaire pour ajouter un message au corps du chat
    function addMessage(message, type) {
        var messageElement = document.createElement('p');
        messageElement.classList.add(type === 'user' ? 'user-message' : 'ai-response');
        messageElement.innerText = message;
        chatBody.appendChild(messageElement);
        // Défile vers le bas pour voir le dernier message
        chatBody.scrollTop = chatBody.scrollHeight;
    }

    // Fonction pour communiquer avec la Netlify Function (Gemini)
    async function sendMessageToGemini(userMessage) {
        addMessage(userMessage, 'user');
        
        // Ajout du message d'attente
        addMessage("L'IA réfléchit...", 'ai-response'); 
        
        // Cible le dernier message pour y mettre la réponse (sera écrasé)
        var waitingMessage = chatBody.lastChild;
        if (waitingMessage) {
            waitingMessage.classList.add('waiting'); 
        }
        
        try {
            var response = await fetch('/.netlify/functions/gemini', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ prompt: userMessage }),
            });
    
            // Retrait du message d'attente ou remplacement du texte
            if (waitingMessage) {
                chatBody.removeChild(waitingMessage); // On retire le message "L'IA réfléchit..."
            }
            
            if (!response.ok) {
                throw new Error(`Erreur Netlify: ${response.status}`);
            }
    
            var data = await response.json();
            addMessage(data.text, 'ai'); // Affiche la réponse de l'IA
    
        } catch (error) {
            console.error('Erreur de communication avec l\'IA:', error);
            
            // Si une erreur survient, on affiche un message d'erreur
            if (waitingMessage) {
                // On retire le message "L'IA réfléchit..." si ce n'est pas déjà fait
                if(chatBody.lastChild === waitingMessage) {
                    chatBody.removeChild(waitingMessage);
                }
            }
            addMessage("Désolé, une erreur est survenue lors de la communication avec l'IA. (Vérifiez votre clé API Netlify)", 'ai');
        }
    }
    
    // Lier la fonction à l'événement de soumission du formulaire
    document.addEventListener('DOMContentLoaded', () => {
        if (chatForm) {
            chatForm.addEventListener('submit', function(e) {
                e.preventDefault(); // Empêche le rechargement de la page
                var userMessage = chatInput.value.trim();
                
                if (userMessage !== '') {
                     sendMessageToGemini(userMessage);
                     chatInput.value = ''; // Efface le champ de saisie
                }
            });
        }
    });
    
    // Optionnel : Basculer l'affichage du corps du chat
    if (chatHeader && chatBodyElement && chatFormElement) {
        chatHeader.addEventListener('click', () => {
            var isHidden = chatBodyElement.style.display === 'none';
            chatBodyElement.style.display = isHidden ? 'flex' : 'none';
            chatFormElement.style.display = isHidden ? 'flex' : 'none';
            chatHeader.innerText = isHidden ? "Assistant IA Gémini" : "Assistant IA Gémini (Masqué)";
        });
    }

</script>
</body>
</html>