<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width">
    <link rel="stylesheet" href="css/leaflet.css">
    <link rel="stylesheet" href="css/L.Control.Layers.Tree.css">
    <link rel="stylesheet" href="css/qgis2web.css">
    <link rel="stylesheet" href="css/fontawesome-all.min.css">
    <link rel="stylesheet" href="css/leaflet-search.css">
    <link rel="stylesheet" href="css/leaflet.photon.css">
    <link rel="stylesheet" href="css/leaflet-measure.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>

    <style>
        /* Styles de base de la carte */
        html, body { height:100%; margin:0; }
        #map { width:100%; height:100%; }

        /* Stabilit√© de la l√©gende (g√©r√©e par JS) */
        .info.legend {
            z-index: 1000;
        }
        
        /* Stabilit√© du Chatbot */
        #chat-container { 
            z-index: 9998 !important; 
            bottom: 20px; 
            right: 20px;
        }
        
        /* Stabilit√© du Filtre centr√© (si des √©l√©ments externes le recouvrent) */
        #filter-controls {
            z-index: 9999;
        }
    </style>
    <title>Carte interactive QGIS2Web</title>
</head>
<body>

<div id="map"></div>

<div id="filter-controls" style="
    position: absolute; 
    top: 10px; 
    left: 70px; /* √Ä c√¥t√© des boutons de zoom */
    z-index: 9999; 
    background: rgba(255, 255, 255, 0.9); 
    padding: 10px; 
    border-radius: 5px; 
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    font-family: Arial, sans-serif;
">
    <select id="filterPhase" onchange="filterVestiges()">
    <option value="Tous">Toutes les Phases</option>
    </select>

<select id="filterType" onchange="filterVestiges()">
    <option value="Tous">Tous les Types</option>
    </select>

    <div id="vestiges-count" style="margin-top: 10px; font-size: 11px;"></div>
	<button id="downloadShpBtn" style="
    margin-top:10px;
    background:#0078ff;
    color:white;
    border:none;
    border-radius:4px;
    padding:6px 10px;
    cursor:pointer;
">
    ‚¨áÔ∏è T√©l√©charger la carte en Geojson
</button>

</div>

<div id="legend-content" style="
    /* ‚ö†Ô∏è Ces styles sont pour l'apparence, la position est g√©r√©e par le JS de Leaflet */
    background: white; 
    padding: 8px; 
    border-radius: 5px; 
    box-shadow: 0 1px 5px rgba(0,0,0,0.4); 
    font-family: sans-serif; 
    font-size: 12px;
    display: none; /* Masqu√© car le contr√¥le Leaflet va le copier/afficher */
">
    <b>L√©gende des Phases :</b>
    
    <div>
        <span style="background: rgba(0, 191, 255, 0.7); border: 1px solid rgba(0, 100, 150, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> N√©olithique (Cyan)
    </div>
    
    <div>
        <span style="background: rgba(128, 0, 128, 0.7); border: 1px solid rgba(64, 0, 64, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Protohistoire (Violet)
    </div>
    
    <div>
        <span style="background: rgba(255, 0, 0, 0.7); border: 1px solid rgba(150, 0, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Antiquit√© (Rouge)
    </div>
    
    <div>
        <span style="background: rgba(144, 238, 144, 0.7); border: 1px solid rgba(0, 100, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> M√©di√©val (Vert clair)
    </div>
    
    <div>
        <span style="background: rgba(255, 255, 153, 0.7); border: 1px solid rgba(200, 200, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Moderne (Jaune clair)
    </div>
    
    <div>
        <span style="background: rgba(255, 140, 0, 0.7); border: 1px solid rgba(150, 80, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Contemporain (Orange)
    </div>
    
    <div>
        <span style="background: rgba(50, 50, 50, 0.9); border: 1px solid rgba(0, 0, 0, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Ind√©termin√© (Noir)
    </div>
    <div>
        <span style="background: rgba(177, 177, 177, 0.5); border: 1px solid rgba(100, 100, 100, 1.0); width: 15px; height: 10px; display: inline-block; margin-right: 5px;"></span> Aucun renseignement (Gris)
    </div>
</div>

<!-- Scripts de base -->
<script src="js/qgis2web_expressions.js"></script>
<script src="js/leaflet.js"></script>
<script src="js/L.Control.Layers.Tree.min.js"></script>
<script src="js/leaflet.rotatedMarker.js"></script>
<script src="js/leaflet.pattern.js"></script>
<script src="js/leaflet-hash.js"></script>
<script src="js/Autolinker.min.js"></script>
<script src="js/rbush.min.js"></script>
<script src="js/labelgun.min.js"></script>
<script src="js/labels.js"></script>
<script src="js/leaflet.photon.js"></script>
<script src="js/leaflet-measure.js"></script>
<script src="js/leaflet-search.js"></script>
<script src="data/Emprise_0.js"></script>
<script src="data/Cadastre_1.js"></script>
<script src="data/Vestiges_2.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://unpkg.com/@mapbox/shp-write@latest/shpwrite.js"></script>

    <script>
// --- INITIALISATION DE LA CARTE ---
var map = L.map('map', {
    zoomControl: false,
    maxZoom: 28,
    minZoom: 1
}).fitBounds([[44.7773913006228,4.819553954184861],[44.77947941499905,4.826186775095028]]);


// ‚úÖ CORRECTION MAJEURE: Emp√™cher le conteneur de filtre personnalis√© de bloquer les clics
var filterControls = document.getElementById('filter-controls');
if (filterControls) {
    // Ceci permet aux clics d'atteindre les contr√¥les Leaflet sous le panneau de filtre.
    L.DomEvent.disableClickPropagation(filterControls);
    L.DomEvent.disableScrollPropagation(filterControls); 
    console.log("Propagation des √©v√©nements d√©sactiv√©e pour #filter-controls.");
}

// --- Code de Contr√¥le Leaflet pour la L√©gende (R√âVIS√â) ---

// 1. D√©finir le contr√¥le personnalis√©
	var legendControl = L.control({
    position: 'topright' // ‚úÖ Positionne la l√©gende en haut √† droite
});

// 2. M√©thode pour obtenir le contenu du contr√¥le
legendControl.onAdd = function (map) {
    // Cr√©e un NOUVEAU conteneur div pour le contr√¥le (classe standard Leaflet)
    var div = L.DomUtil.create('div', 'info legend'); 
    
    // R√©cup√®re le contenu HTML de l'√©l√©ment existant (#legend-content)
    var contentElement = document.getElementById('legend-content');

    // üõë S'assurer que l'√©l√©ment existe avant de continuer
    if (contentElement) {
        // Copie le contenu HTML dans le nouveau conteneur Leaflet
        div.innerHTML = contentElement.innerHTML;
        
        // Optionnel : Cacher l'√©l√©ment HTML original maintenant qu'il est copi√© dans le contr√¥le
        contentElement.style.display = 'none'; 
    } else {
        div.innerHTML = 'L√©gende introuvable.';
    }

    // Assurez-vous que le conteneur du contr√¥le ne propage pas les clics √† la carte
    L.DomEvent.disableClickPropagation(div);

    // Retourner le nouveau conteneur g√©r√© par Leaflet
    return div;
};

// 3. Ajouter le contr√¥le √† la carte
map.addControl(legendControl);

// --- Fin du Code de Contr√¥le R√âVIS√â ---

// --- Hash URL ---
var hash = new L.Hash(map);

// --- Attribution (Correction point m&eacute;dian et accents) ---
map.attributionControl.setPrefix('<a href="https://github.com/tomchadwin/qgis2web" target="_blank">qgis2web</a> &middot; <a href="https://leafletjs.com">Leaflet</a> &middot; <a href="https://qgis.org">QGIS</a>');

// --- Autolinker ---
var autolinker = new Autolinker({truncate: {length: 30, location: 'smart'}});

// --- Contr&ocirc;les ---
var zoomControl = L.control.zoom({ position: 'topleft' }).addTo(map);
var measureControl = new L.Control.Measure({
    position: 'topleft',
    primaryLengthUnit: 'meters',
    secondaryLengthUnit: 'kilometers',
    primaryAreaUnit: 'sqmeters',
    secondaryAreaUnit: 'hectares'
}).addTo(map);
document.getElementsByClassName('leaflet-control-measure-toggle')[0].innerHTML = '';
document.getElementsByClassName('leaflet-control-measure-toggle')[0].className += ' fas fa-ruler';

// --- &Eacute;CHELLE GRAPHIQUE DYNAMIQUE ---
var scaleBar = L.control({position: 'bottomleft'});

scaleBar.onAdd = function(map) {
    var div = L.DomUtil.create('div', 'custom-scale-bar');
    div.innerHTML = `
      <div class="scale-bar-container">
        <div class="scale-segment black"></div>
        <div class="scale-segment white"></div>
        <div class="scale-segment black"></div>
        <span class="scale-label">0 m</span>
      </div>
    `;
    return div;
};

scaleBar.addTo(map);

// --- STYLE VISUEL ---
var scaleBarStyle = document.createElement('style');
scaleBarStyle.innerHTML = `
.custom-scale-bar {
  position: relative;
  width: 100px;
  height: 10px;
  margin: 8px;
  user-select: none;
}
.scale-bar-container {
  display: flex;
  align-items: center;
}
.scale-segment {
  flex: 1;
  height: 8px;
  border: 1px solid #333;
}
.scale-segment.black {
  background: #000;
}
.scale-segment.white {
  background: #fff;
}
.scale-label {
  margin-left: 6px;
  font-size: 11px;
  color: #222;
  font-family: 'Segoe UI', Roboto, sans-serif;
}
`;
document.head.appendChild(scaleBarStyle);

// --- LOGIQUE DYNAMIQUE DE MISE &Agrave; JOUR ---
function updateScaleBar() {
    // largeur de r&eacute;f&eacute;rence en pixels
    var maxBarWidthPx = 100;
    var center = map.getCenter();
    
    // calcul de la distance r&eacute;elle repr&eacute;sent&eacute;e par la barre (m&egrave;tres)
    var pointA = map.containerPointToLatLng([0, map.getSize().y / 2]);
    var pointB = map.containerPointToLatLng([maxBarWidthPx, map.getSize().y / 2]);
    var distanceMeters = map.distance(pointA, pointB);

    // arrondir la valeur &agrave; une &eacute;chelle cartographique "jolie"
    var niceValues = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000];
    var displayValue = niceValues[0];
    for (var i = 0; i < niceValues.length; i++) {
        if (distanceMeters / niceValues[i] < 2) {
            displayValue = niceValues[i];
            break;
        }
    }

    // calcul de la largeur r&eacute;elle en pixels pour cette distance
    var displayWidth = maxBarWidthPx * (displayValue / distanceMeters);

    // mise &agrave; jour visuelle
    var scaleDiv = document.querySelector('.custom-scale-bar');
    if (scaleDiv) {
        var container = scaleDiv.querySelector('.scale-bar-container');
        container.style.width = displayWidth + 'px';
        scaleDiv.querySelector('.scale-label').textContent =
            displayValue >= 1000 ? (displayValue / 1000) + ' km' : displayValue + ' m';
    }
}

// --- METTRE &Agrave; JOUR &Agrave; CHAQUE ZOOM OU D&Eacute;PLACEMENT ---
map.on('zoomend moveend', updateScaleBar);
map.whenReady(updateScaleBar);

    // --- Fonctions popup (Mise &agrave; jour pour affichage lisible) ---
    function removeEmptyRowsFromPopupContent(content, feature) {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        var rows = tempDiv.querySelectorAll('tr');
        for (var i = 0; i < rows.length; i++) {
            var td = rows[i].querySelector('td.visible-with-data');
            var key = td ? td.id : '';
            if (td && td.classList.contains('visible-with-data') && feature.properties[key] == null) {
                rows[i].parentNode.removeChild(rows[i]);
            }
        }
        return tempDiv.innerHTML;
    }

    function addClassToPopupIfMedia(content, popup) {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        var imgTd = tempDiv.querySelector('td img');
        if (imgTd) {
            var src = imgTd.getAttribute('src');
            if (/\.(jpg|jpeg|png|gif|bmp|webp|avif)$/i.test(src)) {
                popup._contentNode.classList.add('media');
                setTimeout(function() { popup.update(); }, 10);
            } else if (/\.(mp3|wav|ogg|aac)$/i.test(src)) {
                var audio = document.createElement('audio');
                audio.controls = true;
                audio.src = src;
                imgTd.parentNode.replaceChild(audio, imgTd);
                popup._contentNode.classList.add('media');
                setTimeout(function() {
                    popup.setContent(tempDiv.innerHTML);
                    popup.update();
                }, 10);
            } else if (/\.(mp4|webm|ogg|mov)$/i.test(src)) {
                var video = document.createElement('video');
                video.controls = true;
                video.src = src;
                video.style.width = "400px";
                video.style.height = "300px";
                video.style.maxHeight = "60vh";
                video.style.maxWidth = "60vw";
                imgTd.parentNode.replaceChild(video, imgTd);
                popup._contentNode.classList.add('media');
                video.addEventListener('loadedmetadata', function() {
                    popup.update();
                });
                setTimeout(function() {
                    popup.setContent(tempDiv.innerHTML);
                    popup.update();
                }, 10);
            } else {
                popup._contentNode.classList.remove('media');
            }
        } else {
            popup._contentNode.classList.remove('media');
        }
    }

    

    var bounds_group = new L.featureGroup([]);
    function setBounds() {}

// --- Emprise ---
    function pop_Emprise_0(feature, layer) {
        var popupContent = '<table>\
            <tr><th>QC_ID</th><td>' + (feature.properties['qc_id'] != null ? Autolinker.link(feature.properties['qc_id'].toString()) : '') + '</td></tr>\
            <tr><th>ID</th><td>' + (feature.properties['id'] != null ? Autolinker.link(feature.properties['id'].toString()) : '') + '</td></tr>\
        </table>';
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on('popupopen', function(e) { addClassToPopupIfMedia(content, e.popup); });
        layer.bindPopup(content, { maxHeight: 400 });
    }

    function style_Emprise_0_0() {
        return {
            pane: 'pane_Emprise_0',
            opacity: 1,
            color: 'rgba(35,35,35,1.0)',
            weight: 1.0,
            fill: true,
            fillOpacity: 1,
            fillColor: 'rgba(0,0,255,0.0)',
            interactive: true,
        }
    }

    map.createPane('pane_Emprise_0');
    map.getPane('pane_Emprise_0').style.zIndex = 400;
    var layer_Emprise_0 = new L.geoJson(json_Emprise_0, {
        onEachFeature: pop_Emprise_0,
        style: style_Emprise_0_0,
        pane: 'pane_Emprise_0',
    });
    bounds_group.addLayer(layer_Emprise_0);
    map.addLayer(layer_Emprise_0);


    // --- Cadastre ---
    function pop_Cadastre_1(feature, layer) {
        var popupContent = '<table>\
            <tr><th>NUM&Eacute;RO</th><td>' + (feature.properties['numero'] != null ? Autolinker.link(feature.properties['numero'].toString()) : '') + '</td></tr>\
        </table>';
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on('popupopen', function(e) { addClassToPopupIfMedia(content, e.popup); });
        layer.bindPopup(content, { maxHeight: 400 });
    }

    function style_Cadastre_1_0() {
        return {
            pane: 'pane_Cadastre_1',
            opacity: 1,
            color: 'rgba(227,26,28,1.0)',
            weight: 1.0,
            fill: true,
            fillOpacity: 1,
            fillColor: 'rgba(243,166,178,0.0)',
            interactive: true,
        }
    }

    map.createPane('pane_Cadastre_1');
    map.getPane('pane_Cadastre_1').style.zIndex = 401;
    var layer_Cadastre_1 = new L.geoJson(json_Cadastre_1, {
        onEachFeature: pop_Cadastre_1,
        style: style_Cadastre_1_0,
        pane: 'pane_Cadastre_1',
    });
    bounds_group.addLayer(layer_Cadastre_1);
    map.addLayer(layer_Cadastre_1);

    // --- Vestiges ---
    function pop_Vestiges_2(feature, layer) {
        var popupContent = '<table>\
            <tr><th>FAIT</th><td>' + (feature.properties['fait'] != null ? Autolinker.link(feature.properties['fait'].toString()) : '') + '</td></tr>\
            <tr><th>PHASE</th><td>' + (feature.properties['Phase'] != null ? Autolinker.link(feature.properties['Phase'].toString()) : '') + '</td></tr>\
            <tr><th>TYPE</th><td>' + (feature.properties['Type'] != null ? Autolinker.link(feature.properties['Type'].toString()) : '') + '</td></td></tr>\
			<tr><th>MOBILIER C</th><td>' + (feature.properties['Mobilier C'] != null ? Autolinker.link(feature.properties['Mobilier C'].toString()) : '') + '</td></td></tr>\
			<tr><th>MOBILIER F</th><td>' + (feature.properties['Mobilier F'] != null ? Autolinker.link(feature.properties['Mobilier F'].toString()) : '') + '</td></td></tr>\
        </table>';
        var content = removeEmptyRowsFromPopupContent(popupContent, feature);
        layer.on('popupopen', function(e) { addClassToPopupIfMedia(content, e.popup); });
        layer.bindPopup(content, { maxHeight: 400 });
    }

   // --- Vestiges : Fonction de style modifi√©e pour la couleur th√©matique (Ordonn√©e Chronologiquement) ---
function style_Vestiges_2_0(feature) {
    let phase = feature.properties.Phase ? String(feature.properties.Phase).toLowerCase().trim() : 'aucun renseignement';
    let fillColor;
    let color;
    let weight = 1.5;
    let fillOpacity = 0.7;

    // D√©finition des couleurs par phase (Chronologie: N√©olithique -> Contemporain)
    switch (phase) {
        // >>> 1. N√©olithique (Cyan) <<<
        case 'n√©olithique':
        case 'neolithique': 
            // Cyan pour le N√©olithique
            fillColor = 'rgba(0, 191, 255, 0.7)'; // Deep Sky Blue
            color = 'rgba(0, 100, 150, 1.0)';
            break;
        
        // >>> 2. Protohistoire (Violet) <<<
        case 'protohistoire':
            // Violet pour la Protohistoire
            fillColor = 'rgba(128, 0, 128, 0.7)'; // Purple
            color = 'rgba(64, 0, 64, 1.0)';
            break;

        // >>> 3. Antiquit√© (Rouge) <<<
        case 'antiquit√©':
            // Rouge pour l'Antiquit√©
            fillColor = 'rgba(255, 0, 0, 0.7)';
            color = 'rgba(150, 0, 0, 1.0)';
            break;

        // >>> 4. M√©di√©val (Vert clair) <<<
        case 'm√©di√©val':
            // Vert clair pour le M√©di√©val
            fillColor = 'rgba(144, 238, 144, 0.7)'; // LightGreen
            color = 'rgba(0, 100, 0, 1.0)';
            break;

        // >>> 5. Moderne (Jaune clair) <<<
        case 'moderne':
            // Jaune clair pour le Moderne
            fillColor = 'rgba(255, 255, 153, 0.7)'; // LightYellow
            color = 'rgba(200, 200, 0, 1.0)';
            break;

        // >>> 6. Contemporain (Orange) <<<
        case 'contemporain':
            // Orange fonc√© pour le Contemporain
            fillColor = 'rgba(255, 140, 0, 0.7)'; // Dark Orange
            color = 'rgba(150, 80, 0, 1.0)';
            break;
        
        // --- Cas Sp√©ciaux (Ind√©termin√©/Inconnu) ---
        case 'indetermine':
        case 'ind√©termin√©': // Gestion des accents
            // Noir pour Ind√©termin√©
            fillColor = 'rgba(50, 50, 50, 0.9)'; 
            color = 'rgba(0, 0, 0, 1.0)';
            fillOpacity = 0.9;
            break;
        default:
            // Gris pour 'Aucun renseignement' / Inconnu
            fillColor = 'rgba(177, 177, 177, 0.5)';
            color = 'rgba(100, 100, 100, 1.0)';
            weight = 1.0;
            fillOpacity = 0.5;
    }

    return {
        pane: 'pane_Vestiges_2',
        opacity: 1,
        color: color,
        weight: weight,
        fill: true,
        fillOpacity: fillOpacity,
        fillColor: fillColor,
        interactive: true,
    }
}

    map.createPane('pane_Vestiges_2');
    map.getPane('pane_Vestiges_2').style.zIndex = 402;
    var layer_Vestiges_2 = new L.geoJson(json_Vestiges_2, {
        onEachFeature: pop_Vestiges_2,
        style: style_Vestiges_2_0,
        pane: 'pane_Vestiges_2',
    });
    bounds_group.addLayer(layer_Vestiges_2);
    map.addLayer(layer_Vestiges_2);

    // --- Labels et recherche ---
    var i = 0;
    layer_Vestiges_2.eachLayer(function(layer) {
        layer.bindTooltip((layer.feature.properties['fait'] ? 
            '<div style="color: #323232; font-size: 5pt; font-weight: bold; font-style: italic; font-family: Times New Roman, sans-serif;">' + 
            layer.feature.properties['fait'] + '</div>' : ''), 
            {permanent: true, offset: [0, -16], className: 'css_Vestiges_2'});
        labels.push(layer);
        totalMarkers += 1;
        layer.added = true;
        addLabel(layer, i);
        i++;
    });

    map.addControl(new L.Control.Search({
        layer: layer_Vestiges_2,
        initial: false,
        hideMarkerOnCollapse: true,
        propertyName: 'fait'
    }));

    if (typeof url === 'undefined') {
        document.getElementsByClassName('search-button')[0].className += ' fa fa-binoculars';
    } else {
        document.getElementsByClassName('search-button')[1].className += ' fa fa-binoculars';
    }

    map.on("zoomend", function(){
    resetLabels([window.layer_Vestiges_2_Filtered || layer_Vestiges_2]);
});
    </script>
    
    <script>
// --- AJOUT DU CONTR√îLE DE DESSIN ET DES ATTRIBUTS ---

// 1. Cr√©er un groupe de calques pour stocker les √©l√©ments dessin√©s
var drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

// 2. Configurer le contr√¥le de dessin
var drawControl = new L.Control.Draw({
    // ‚úÖ Positionnement en bas √† gauche
    position: 'topleft', 
    edit: {
        featureGroup: drawnItems, // Permet d'√©diter/supprimer les √©l√©ments dessin√©s
        remove: true
    },
    draw: {
        polygon: {
            allowIntersection: false, 
            showArea: true 
        },
        // Seul le polygone est activ√© selon votre configuration
        polyline: false, 
        circle: false,   
        marker: false,   
        rectangle: false, 
        circlemarker: false  
    }
});

// üí• AJOUTER LE CONTR√îLE √Ä LA CARTE
map.addControl(drawControl); 

// 3. G√©rer l'√©v√©nement de cr√©ation d'un √©l√©ment
map.on(L.Draw.Event.CREATED, function (e) {
    var type = e.layerType,
        layer = e.layer;

    if (type === 'polygon') {
        
        // --- Collecte des rubriques (attributs) via des bo√Ætes de dialogue ---
        var faitVal = prompt("Entrez la valeur pour 'FAIT' (ex: F99) :");
        if (faitVal === null || faitVal.trim() === "") {
            // Annuler si l'utilisateur ne donne pas de nom de Fait
            return;
        }

        var phaseVal = prompt("Entrez la valeur pour 'PHASE' (ex: antiquit√©, m√©di√©val, inconnue) :");
        var typeVal = prompt("Entrez la valeur pour 'TYPE' (ex: Mur, Sol, Fosse) :");
        var mobilierCVal = prompt("Entrez la valeur pour 'MOBILIER C' (ex: 30,26,45) :");
        var mobilierFVal = prompt("Entrez la valeur pour 'MOBILIER F' (ex: 25,89,78) :");
        
        // 4. Cr√©er la structure GeoJSON avec les nouvelles rubriques
        var feature = layer.toGeoJSON();
        feature.properties = {
            'fait': faitVal.trim(),
            'Phase': (phaseVal || 'inconnue').trim(),
            'Type': (typeVal || 'non d√©fini').trim(),
            'Mobilier C': (mobilierCVal || '').trim(),
            'Mobilier F': (mobilierFVal || '').trim()
        };

        // 5. Cr√©er une nouvelle couche Leaflet √† partir du GeoJSON pour styliser et ajouter le popup
        var newLayer = L.geoJson(feature, {
            onEachFeature: function(feature, layer) {
                 // Recr√©er le contenu du popup avec les rubriques saisies
                 var popupContent = '<table>\
                    <tr><th>FAIT</th><td>' + feature.properties['fait'] + '</td></tr>\
                    <tr><th>PHASE</th><td>' + feature.properties['Phase'] + '</td></tr>\
                    <tr><th>TYPE</th><td>' + feature.properties['Type'] + '</td></td></tr>\
                    <tr><th>MOBILIER C</th><td>' + feature.properties['Mobilier C'] + '</td></td></tr>\
                    <tr><th>MOBILIER F</th><td>' + feature.properties['Mobilier F'] + '</td></td></tr>\
                 </table>';
                 layer.bindPopup(popupContent, { maxHeight: 400 });
                 
                 // Appliquer un style visuel simple pour diff√©rencier les √©l√©ments dessin√©s
                 layer.setStyle({
                     // 1. Bordure : Noir ou Gris fonc√© uni (opacit√© 1.0)
                     color: '#000000', // Noir, ou 'rgba(0, 0, 0, 1.0)' si vous pr√©f√©rez
                     weight: 3, 
                     opacity: 1.0, 
                     
                     // 2. Remplissage : Gris fonc√© (opacit√© 0.7 √† 0.9 pour qu'il soit transparent)
                     fillColor: '#323232', // √âquivalent de rgba(50, 50, 50, 0.9)
                     fillOpacity: 0.7 // Une opacit√© plus faible pour le remplissage (0.7)
                 });
            }
        });

        // 6. Ajouter les √©l√©ments dessin√©s au groupe (ils deviennent visibles et √©ditables)
        newLayer.eachLayer(function(l) {
            drawnItems.addLayer(l);
        });
        
        console.log("Nouveau polygone dessin√© et attributs enregistr√©s.", feature.properties);
    }
});
    </script>
    
    <script>
    (function(){
        // --- Dictionnaire corrig&eacute; ---
        var layerLookup = {
            "Cadastre": layer_Cadastre_1,
            "Vestiges": layer_Vestiges_2
        };

        function normalizeStr(s){
            if (s === null || s === undefined) return "";
            return String(s).toLowerCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/\s+/g,' ').trim();
        }

        function zoomToLayerItem(layerItem){
            if (typeof layerItem.getLatLng === 'function'){
                map.setView(layerItem.getLatLng(), 22);
            } else if (typeof layerItem.getBounds === 'function'){
                map.fitBounds(layerItem.getBounds().pad(0.01), { maxZoom: 22 });
            }
            if (layerItem.openPopup) layerItem.openPopup();
        }

        function searchAllLayers(searchValue){
            var target = normalizeStr(searchValue);
            var matches = [];
            Object.keys(layerLookup).forEach(function(layerName){
                var lyr = layerLookup[layerName];
                if (!lyr) return;
                lyr.eachLayer(function(layerItem){
                    var props = (layerItem.feature && layerItem.feature.properties) || {};
                    for (var key in props){
                        if (!props.hasOwnProperty(key)) continue;
                        var val = normalizeStr(props[key]);
                        if (val && (val === target || val.indexOf(target) !== -1)){
                            matches.push({
                                layerName: layerName,
                                field: key,
                                value: props[key],
                                layerItem: layerItem
                            });
                        }
                    }
                });
            });
            return matches;
        }

        function zoomToByAnyField(searchValue){
            if (!searchValue) {
                // Correction encodage
                console.warn("Valeur vide");
                return false;
            }
            var results = searchAllLayers(searchValue);
            if (results.length === 0){
                // Correction encodage
                console.warn("Aucun r&eacute;sultat trouv&eacute; pour:", searchValue);
                return false;
            }
            // Correction encodage
            console.log("R&eacute;sultats:", results);

            if (results.length > 1){
                var group = L.featureGroup(results.map(r=>r.layerItem));
                map.fitBounds(group.getBounds().pad(0.01), { maxZoom: 22 });
                results[0].layerItem.openPopup();
            } else {
                zoomToLayerItem(results[0].layerItem);
            }
            return true;
        }

        window.zoomToByAnyField = zoomToByAnyField;

        var urlVal = new URLSearchParams(window.location.search).get("search");
        if (urlVal){
            var tries=0, poll=setInterval(function(){
                tries++;
                if (layer_Vestiges_2 && layer_Vestiges_2.getLayers().length>0){
                    clearInterval(poll);
                    zoomToByAnyField(decodeURIComponent(urlVal));
                }
                if (tries>50) clearInterval(poll);
            },200);
        }
    })();
    </script>
    <script>
// Sauvegarde de toutes les entit√©s de la couche Vestiges
var allVestiges = layer_Vestiges_2.toGeoJSON();

// --- Normalisation et s√©curisation Unicode (D√âPLAC√âES POUR R√âUTILISATION) ---
// Note: Le normalize('NFC') garde les accents correctement affich√©s si la donn√©e source les a.
const normalize = str => {
    if (!str) return null;
    return String(str)
        .trim()
        .replace(/\s+/g, ' ')
        .normalize('NFC'); 
};

const capitalize = str => {
    if (!str) return '';
    const s = str.toLowerCase();
    return s.charAt(0).toUpperCase() + s.slice(1);
};

// Fonction utilitaire pour obtenir la valeur de comparaison normalis√©e
function getNormalizedComparisonValue(rawValue) {
    if (!rawValue) return 'N/A';
    // Cette fonction reproduit la logique utilis√©e pour cr√©er la valeur de l'option dans populateFilters
    return capitalize(normalize(rawValue));
}
// =================================================================

// =================================================================
// 1. FONCTION DE REMPLISSAGE DES FILTRES (Rend les menus d√©roulants utilisables)
// =================================================================

function populateFilters() {
    const phaseFilter = document.getElementById('filterPhase');
    const typeFilter  = document.getElementById('filterType');

    if (!json_Vestiges_2 || !json_Vestiges_2.features) {
        console.error("Erreur : donn√©es 'json_Vestiges_2' introuvables.");
        return;
    }

    const uniquePhases = new Map();
    const uniqueTypes  = new Map();

    json_Vestiges_2.features.forEach(f => {
        // Applique la normalisation pour obtenir une cl√© de comparaison coh√©rente
        const phaseKey = normalize(f.properties.Phase); 
        const phaseValue = capitalize(phaseKey); 

        const typeKey = normalize(f.properties.Type);
        const typeValue = capitalize(typeKey);

        if (phaseKey && phaseKey !== 'null' && phaseKey !== 'undefined') {
            uniquePhases.set(phaseKey, phaseValue);
        }
        if (typeKey && typeKey !== 'null' && typeKey !== 'undefined') {
            uniqueTypes.set(typeKey, typeValue);
        }
    });

    // --- Nettoyage avant r√©injection ---
    phaseFilter.innerHTML = '<option value="Tous">Toutes les Phases</option>';
    typeFilter.innerHTML  = '<option value="Tous">Tous les Types</option>';

    // --- Ajout tri√© et encod√© correctement ---
    Array.from(uniquePhases.values()).sort((a, b) => a.localeCompare(b, 'fr')).forEach(phase => {
        const opt = document.createElement('option');
        opt.value = phase;
        opt.textContent = phase; 
        phaseFilter.appendChild(opt);
    });

    Array.from(uniqueTypes.values()).sort((a, b) => a.localeCompare(b, 'fr')).forEach(type => {
        const opt = document.createElement('option');
        opt.value = type;
        opt.textContent = type;
        typeFilter.appendChild(opt);
    });
}

// =================================================================
// 2. FONCTION DE FILTRAGE (R√®gle le probl√®me d'accent par une comparaison normalis√©e)
// =================================================================

function filterVestiges() {
    // 2.1 R√©cup√©rer les valeurs s√©lectionn√©es dans les filtres
    const selectedPhase = document.getElementById('filterPhase').value;
    const selectedType = document.getElementById('filterType').value;
    
    // 2.2 Retirer la couche actuelle de la carte
    if (map.hasLayer(layer_Vestiges_2)) {
        map.removeLayer(layer_Vestiges_2);
    }
    
    // 2.3 Filtrer les donn√©es GeoJSON originales
    const filteredFeatures = json_Vestiges_2.features.filter(feature => {
        // --- CORRECTION CL√â : Normaliser la valeur de la donn√©e source (feature) 
        // pour la faire correspondre √† la valeur de l'option (selectedPhase)
        const featurePhaseNormalized = getNormalizedComparisonValue(feature.properties.Phase);
        const featureTypeNormalized  = getNormalizedComparisonValue(feature.properties.Type);
        
        // La comparaison est maintenant robuste car elle utilise la m√™me convention
        const phaseMatch = (selectedPhase === 'Tous') || (selectedPhase === featurePhaseNormalized);
        const typeMatch  = (selectedType === 'Tous')  || (selectedType === featureTypeNormalized);
        
        return phaseMatch && typeMatch;
    });

    // 2.4 Cr√©er un nouvel objet GeoJSON avec les entit√©s filtr√©es
    const filteredGeoJSON = {
        "type": "FeatureCollection",
        "features": filteredFeatures
    };

    // 2.5 Recr√©er et ajouter la couche Leaflet GeoJSON filtr√©e

    if (window.layer_Vestiges_2_Filtered) {
        map.removeLayer(window.layer_Vestiges_2_Filtered);
    }

    window.layer_Vestiges_2_Filtered = L.geoJson(filteredGeoJSON, {
        attribution: '',
        interactive: true,
        style: style_Vestiges_2_0,
        onEachFeature: pop_Vestiges_2,
        pointToLayer: (feature, latlng) => L.circleMarker(latlng, style_Vestiges_2_0(feature))
    });

    window.layer_Vestiges_2_Filtered.addTo(map);

    // 2.7 R√©initialiser les labels
    if (typeof resetLabels === "function") {
        resetLabels([window.layer_Vestiges_2_Filtered]);
    }

    // 2.8 Mettre √† jour le compteur d'entit√©s
    const countDiv = document.getElementById('vestiges-count');
    if (countDiv) {
        countDiv.textContent = `${filteredFeatures.length} vestige(s) affich√©(s)`;
    }

    console.log(`‚úÖ ${filteredFeatures.length} entit√©s filtr√©es affich√©es.`);
}

// =================================================================
// 3. APPEL MANQUANT (Assure le remplissage du menu au chargement)
// =================================================================

// Remplir les menus d√©roulants une fois que la carte et les donn√©es sont pr√™tes.
map.whenReady(function() {
    if (typeof json_Vestiges_2 !== 'undefined') {
        populateFilters();
    }
});
</script>
<div id="chat-container" style="
    position:absolute;
    bottom:15px;
    right:15px;
    width:320px;
    background:white;
    border-radius:10px;
    box-shadow:0 2px 8px rgba(0,0,0,0.25);
    font-family:sans-serif;
    overflow:hidden;
    z-index:10000;">
    <div id="chat-header" style="
        background:#2b2b2b;
        color:white;
        padding:6px 8px;
        font-weight:bold;
        cursor:pointer;">
        &#128172; LocalAi
    </div>
    <div id="chat-log" style="
        height:200px;
        overflow-y:auto;
        padding:6px;
        font-size:13px;
        background:#fafafa;
        display:none;"></div>
    <div style="display:none; border-top:1px solid #ccc;">
        <input id="chat-input" type="text" placeholder="Pose ta question..." 
            style="flex:1; border:none; padding:6px; font-size:13px;">
        <button id="chat-send" style="background:#2b2b2b; color:white; border:none; padding:6px 10px;">&#9654;</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
// --- D&eacute;finition de Lambert 93 ---
proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
// D√©finition RGF93 / Lambert CC44 (Zone 4)
proj4.defs("EPSG:3944", "+proj=lcc +lat_0=44 +lon_0=3 +lat_1=43.25 +lat_2=44.75 +x_0=1500000 +y_0=3200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
// D√©finition RGF93 / Lambert CC45 (Zone 5)
proj4.defs("EPSG:3945", "+proj=lcc +lat_0=45 +lon_0=3 +lat_1=44.25 +lat_2=45.75 +x_0=1700000 +y_0=4200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
// --- R&eacute;f&eacute;rences HTML ---
const chatLog = document.getElementById('chat-log');
const chatInput = document.getElementById('chat-input');
const chatSend = document.getElementById('chat-send');
const chatHeader = document.getElementById('chat-header');

// --- Toggle ouverture/fermeture ---
chatHeader.addEventListener('click', () => {
    const wasVisible = chatLog.style.display !== 'none';
    chatLog.style.display = wasVisible ? 'none' : 'block';
    chatInput.parentNode.style.display = wasVisible ? 'none' : 'flex';
    
    // Si on ouvre, afficher le message initial (si c'est le premier message)
    if (!wasVisible && chatLog.children.length === 0) {
         appendMessage("&#129302; IA", "Bonjour ! Je suis l'assistant g&eacute;ospatial. Posez-moi une question sur un <b>fait</b> (ex: F12) ou essayez une question g&eacute;n&eacute;rale.");
    }
});

// --- Fonction affichage messages ---
function appendMessage(sender, message) {
    const div = document.createElement('div');
    div.style.marginBottom = '6px';
    div.innerHTML = `<b>${sender}:</b> ${message}`;
    chatLog.appendChild(div);
    chatLog.scrollTop = chatLog.scrollHeight;
}

// --- Zoom sur une couche ---
function zoomToLayer(layer) {
    if (layer.getBounds) {
        map.fitBounds(layer.getBounds().pad(0.02));
        if (layer.openPopup) layer.openPopup();
    }
}

// --- UTILITAIRE : Recherche d'un fait Leaflet ---
// --- UTILITAIRE : Recherche d'un fait Leaflet (robuste, compatible MultiPolygon et variantes de nom) ---
function getVestigeLayer(faitNom) { 
    if (typeof faitNom !== 'string' || faitNom.trim().length < 1) return null;

    // üîß Normalisation du nom : majuscules, sans espaces ni caract√®res sp√©ciaux
    const nomRecherche = faitNom
        .toUpperCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // enl√®ve les accents
        .replace(/\s+/g, '') // enl√®ve les espaces
        .trim();

    let featureTrouvee = null;

    if (!window.layer_Vestiges_2) return null;

    layer_Vestiges_2.eachLayer(layer => { 
        let nomEntite = (layer.feature?.properties?.fait || '')
            .toUpperCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
            .replace(/\s+/g, '')
            .trim();

        if (nomEntite === nomRecherche) {
            featureTrouvee = layer;
        }
    }); 

    // üîç Si rien trouv√©, tenter correspondance partielle (ex: "SP1033A" pour "SP1033")
    if (!featureTrouvee) {
        layer_Vestiges_2.eachLayer(layer => { 
            const nomEntite = (layer.feature?.properties?.fait || '')
                .toUpperCase()
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/\s+/g, '')
                .trim();
            if (nomEntite.startsWith(nomRecherche)) {
                featureTrouvee = layer;
            }
        });
    }

    // ‚úÖ Si toujours rien, v√©rifie si c‚Äôest un MultiPolygon mal r√©f√©renc√©
    if (!featureTrouvee) {
        console.warn(`‚ö†Ô∏è Aucune entit√© trouv√©e pour "${faitNom}". V√©rifie la casse ou le type de g√©om√©trie.`);
    }

    return featureTrouvee; 
}


// --- FONCTION UTILITAIRE : AFFICHAGE DE L'HEURE ET DE LA DATE ---
function getFormattedDateTime() {
    const now = new Date();
    
    // Options pour la date compl&egrave;te (Jour de la semaine, jour du mois, mois, ann&eacute;e)
    const dateOptions = { 
        weekday: 'long', 
        year: 'numeric', 
        month: 'long', 
        day: 'numeric' 
    };
    
    // Options pour l'heure (Heure, minute, seconde)
    const timeOptions = { 
        hour: '2-digit', 
        minute: '2-digit', 
        second: '2-digit', 
        hour12: false // Format 24h
    };

    const formattedDate = new Intl.DateTimeFormat('fr-FR', dateOptions).format(now);
    const formattedTime = new Intl.DateTimeFormat('fr-FR', timeOptions).format(now);

    return `Nous sommes le <b>${formattedDate}</b>. Il est actuellement <b>${formattedTime}</b> (heure locale).`;
}

// -----------------------------------------------------------------


// --- Analyse compl&egrave;te d'un fait (Corrections encodage dans les strings) ---
function analyserFait(faitNom) {
    const featureTrouvee = getVestigeLayer(faitNom);

    // Corrections encodage
    if (!featureTrouvee) return `?? Aucun fait nomm&eacute; &laquo; ${faitNom} &raquo; n&rsquo;a &eacute;t&eacute; trouv&eacute;.`;

    const feat = featureTrouvee.feature;
    // Corrections encodage
    if (!feat.geometry || !feat.geometry.type.includes("Polygon")) return `?? Le fait &laquo; ${faitNom} &raquo; n&rsquo;est pas un polygone.`;

    const area = turf.area(feat); // m2
    const perimeter = turf.length(turf.polygonToLine(feat)) * 1000; // m
    const bbox = turf.bbox(feat);
    const centroid = turf.centroid(feat);
    const diametre = 2 * Math.sqrt(area / Math.PI); 
    const largeur = (bbox[2] - bbox[0]) * 111320; // approx m
    const hauteur = (bbox[3] - bbox[1]) * 111320;

    const centerLambert = proj4('EPSG:4326','EPSG:2154', centroid.geometry.coordinates);

    // --- Parcelle intersectante ---
    let parcelleNum = "Aucune";
    layer_Cadastre_1.eachLayer(parcelle => {
        if (turf.intersect(feat, parcelle.feature)) {
            parcelleNum = parcelle.feature.properties.numero || "inconnue";
        }
    });

    const fmt = new Intl.NumberFormat('fr-FR', { maximumFractionDigits: 2 });
    const html = `
        <b>Analyse du fait ${faitNom}</b><br>
        &bull; Surface : <b>${fmt.format(area)} m&sup2;</b><br>
        &bull; P&eacute;rim&egrave;tre : <b>${fmt.format(perimeter)} m</b><br>
        &bull; Largeur : <b>${fmt.format(largeur)} m</b><br>
        &bull; Longueur : <b>${fmt.format(hauteur)} m</b><br>
        &bull; Diam&egrave;tre &eacute;quivalent : <b>${fmt.format(diametre)} m</b><br>
        &bull; Centre (Lambert 93) : X=${fmt.format(centerLambert[0])}, Y=${fmt.format(centerLambert[1])}<br>
        &bull; Parcelle cadastrale : <b>${parcelleNum}</b>
    `;

    zoomToLayer(featureTrouvee);
    return html;
}

// --- Fonction pour calculer la distance entre deux faits ---
function distanceEntreFaits(faitA, faitB) {
    const fmt = new Intl.NumberFormat('fr-FR', { maximumFractionDigits: 2 });
    const layerA = getVestigeLayer(faitA);
    const layerB = getVestigeLayer(faitB);

    // Corrections encodage
    if (!layerA || !layerB) {
        return `?? Je n&rsquo;ai pas trouv&eacute; le fait ${!layerA ? faitA : faitB} sur la carte.`;
    }

    // Calcul des centro&iuml;des (point de r&eacute;f&eacute;rence)
    const centerA = turf.centroid(layerA.feature);
    const centerB = turf.centroid(layerB.feature);

    // Calcul de la distance en kilom&egrave;tres, puis conversion en m&egrave;tres
    const distanceKm = turf.distance(centerA, centerB);
    const distanceMeters = distanceKm * 1000;

    // Zoom sur l'emprise des deux points (utile pour l'utilisateur)
    const featureGroup = L.featureGroup([layerA, layerB]);
    map.fitBounds(featureGroup.getBounds().pad(0.05));

    // Corrections encodage
    return `La distance entre les centres du fait <b>${faitA}</b> et du fait <b>${faitB}</b> est de <b>${fmt.format(distanceMeters)} m&egrave;tres</b>.`;
}

// --- Fonction pour extraire uniquement coordonn&eacute;es Lambert ---
function coordonneesLambert(faitNom) {
    const featureTrouvee = getVestigeLayer(faitNom);
    // Corrections encodage
    if (!featureTrouvee) return `?? Aucun fait nomm&eacute; &laquo; ${faitNom} &raquo; n&rsquo;a &eacute;t&eacute; trouv&eacute;`;
    const centroid = turf.centroid(featureTrouvee.feature);
    const centerLambert = proj4('EPSG:4326','EPSG:2154', centroid.geometry.coordinates);
    zoomToLayer(featureTrouvee);
    // Corrections encodage
    return `Centre du fait <b>${faitNom}</b> (Lambert 93) : X=${centerLambert[0].toFixed(2)}, Y=${centerLambert[1].toFixed(2)}`;
}

// --- Fonction pour dimensions et surface ---
function dimensionsFait(faitNom) {
    const featureTrouvee = getVestigeLayer(faitNom);
    // Corrections encodage
    if (!featureTrouvee) return `?? Aucun fait nomm&eacute; &laquo; ${faitNom} &raquo; n&rsquo;a &eacute;t&eacute; trouv&eacute;.`;
    const feat = featureTrouvee.feature;
    // Corrections encodage
    if (!feat.geometry || !feat.geometry.type.includes("Polygon")) return `?? Le fait &laquo; ${faitNom} &raquo; n&rsquo;est pas un polygone.`;
    const area = turf.area(feat);
    const bbox = turf.bbox(feat);
    const largeur = (bbox[2]-bbox[0])*111320;
    const hauteur = (bbox[3]-bbox[1])*111320;
    zoomToLayer(featureTrouvee);
    // Corrections encodage
    return `Dimensions du fait <b>${faitNom}</b> : Largeur=${largeur.toFixed(2)} m, Longueur=${hauteur.toFixed(2)} m, Surface=${area.toFixed(2)} m&sup2;`;
}

// --- Fonction pour num&eacute;ro de parcelle ---
function parcelleFait(faitNom) {
    const featureTrouvee = getVestigeLayer(faitNom);
    // Corrections encodage
    if (!featureTrouvee) return `?? Aucun fait nomm&eacute; &laquo; ${faitNom} &raquo; n&rsquo;a &eacute;t&eacute; trouv&eacute;.`;
    const feat = featureTrouvee.feature;
    let parcelleNum = "Aucune";
    layer_Cadastre_1.eachLayer(parcelle => {
        if (turf.intersect(feat, parcelle.feature)) parcelleNum = parcelle.feature.properties.numero || "inconnue";
    });
    zoomToLayer(featureTrouvee);
    return `Le fait <b>${faitNom}</b> se trouve dans la parcelle cadastrale : <b>${parcelleNum}</b>`;
}

// --- Fonction pour lister tous les faits dans une parcelle sp&eacute;cifique ---
function listerFaitsDansParcelle(parcelleNum) {
    const parcelleNormalisee = parcelleNum.toUpperCase();
    let parcelleLayer = null;
    let faitsList = [];

    // 1. Trouver la parcelle cible
    layer_Cadastre_1.eachLayer(layer => {
        if (layer.feature.properties.numero && layer.feature.properties.numero.toUpperCase() === parcelleNormalisee) {
            parcelleLayer = layer;
        }
    });

    // Corrections encodage
    if (!parcelleLayer) {
        return `?? Parcelle cadastrale num&eacute;ro &laquo; ${parcelleNum} &raquo; non trouv&eacute;e.`;
    }

    const geomParcelle = parcelleLayer.feature;

    // 2. Trouver les faits &agrave; l'int&eacute;rieur de cette parcelle
    layer_Vestiges_2.eachLayer(layer => {
        const geomFait = layer.feature;
        if (geomFait && geomFait.geometry.type.includes("Polygon")) {
            // Utilise turf.intersect pour v&eacute;rifier l'intersection spatiale
            const intersection = turf.intersect(geomFait, geomParcelle);
            if (intersection) {
                faitsList.push(layer.feature.properties.fait);
            }
        }
    });

    // 3. Zoom et affichage
    zoomToLayer(parcelleLayer);

    // Corrections encodage
    if (faitsList.length > 0) {
        const listeFaits = faitsList.map(f => `&bull; <b>${f}</b>`).join('<br>');
        return `Il y a <b>${faitsList.length}</b> fait(s) dans la parcelle <b>${parcelleNormalisee}</b> :<br>${listeFaits}`;
    } else {
        return `Aucun fait arch&eacute;ologique n&rsquo;a &eacute;t&eacute; trouv&eacute; dans la parcelle <b>${parcelleNormalisee}</b>.`;
    }
}


// --- BASE DE DONN&Eacute;ES SIMUL&Eacute;E : ALTIM&Eacute;TRIE (en m&egrave;tres) ---
// Note : Ces valeurs sont des exemples et doivent &ecirc;tre bas&eacute;es sur un MNT ou des mesures r&eacute;elles.
const FAIT_ALTIMETRY = {
    "F01": 102.5,
    "F02": 103.1,
    "F03": 104.0,
    "F04": 102.8,
    "F05": 105.5, // Ex: un fait sur une l&eacute;g&egrave;re &eacute;l&eacute;vation
    "F06": 101.9,
    "F07": 103.5,
    "F08": 102.2,
    "F09": 104.9,
    "F10": 103.7,
    "F11": 103.0, 
    "F12": 104.2,
};

// --- Fonction pour obtenir l'altitude ---
function getAltimetry(faitNom) {
    const nomNormalise = faitNom.toUpperCase();
    const altitude = FAIT_ALTIMETRY[nomNormalise];

    if (altitude === undefined) {
        // Corrections encodage
        return `Altitude non r&eacute;f&eacute;renc&eacute;e pour le fait &laquo; ${nomNormalise} &raquo; dans ma base.`;
    }
    
    // Tentative de zoom pour indiquer l'objet
    const featureTrouvee = getVestigeLayer(faitNom);
    if (featureTrouvee) {
        zoomToLayer(featureTrouvee);
    }
    
    // Corrections encodage
    return `L'altitude (Z) estim&eacute;e pour le fait <b>${nomNormalise}</b> est de <b>${altitude.toFixed(2)} m&egrave;tres</b> (au-dessus du niveau moyen de la mer).`;
}
function faitsDansRayon(faitCentralNom, distanceMetres) {
    // 1. D√âCLARATION layerCentral (pour √©viter l'ancienne ReferenceError)
    const layerCentral = getVestigeLayer(faitCentralNom); 

    if (!layerCentral) {
        return `?? Je n‚Äôai pas trouv√© le fait central ¬´ ${faitCentralNom} ¬ª dans la couche des vestiges.`;
    }

    // --- Gestion du Fait Central ---
    let featureCentral = layerCentral.feature;
    if (!featureCentral || !featureCentral.geometry) {
        return `‚ö†Ô∏è G√©om√©trie absente pour ¬´ ${faitCentralNom} ¬ª.`;
    }

    // Calcul du point central (strat√©gie la plus fiable)
    let centerPoint;
    try {
        // ESSAI 1 : Tente le centre de masse (plus pr√©cis pour MultiPolygons)
        centerPoint = turf.centerOfMass(featureCentral); 
    } catch (e) {
        try {
            // ESSAI 2 : Fallback √† pointOnFeature (le plus fiable pour obtenir un point interne)
            centerPoint = turf.pointOnFeature(featureCentral);
        } catch (e2) {
            console.error(`‚ùå √âchec de la d√©termination du point central pour ${faitCentralNom}:`, e2);
            return `‚ö†Ô∏è G√©om√©trie invalide pour ¬´ ${faitCentralNom} ¬ª. Impossible de calculer un point de r√©f√©rence.`;
        }
    }


    // --- Cr√©ation du Buffer ---
    const distanceKm = distanceMetres / 1000;
    let buffer;
    try {
        buffer = turf.buffer(centerPoint, distanceKm, { units: 'kilometers' });
    } catch (e) {
        console.error("‚ùå Erreur dans turf.buffer :", e);
        return `‚ö†Ô∏è Erreur lors du calcul du tampon autour de ¬´ ${faitCentralNom} ¬ª.`;
    }

    if (!buffer || !buffer.geometry) {
        return `‚ö†Ô∏è Impossible de g√©n√©rer un tampon valide autour du fait ¬´ ${faitCentralNom} ¬ª.`;
    }

    // --- 2. BOUCLE DE RECHERCHE ULTRA-D√âFENSIVE (Correction de l'erreur 'length') ---
    
    const faitsTrouves = [];
    layer_Vestiges_2.eachLayer(layer => {
        const faitNom = layer.feature?.properties?.fait; 
        
        // 1. Ignorer le fait central et les entit√©s sans nom
        if (!faitNom || faitNom.toUpperCase() === faitCentralNom.toUpperCase()) return;

        let featureFait = layer.feature;
        
        // 2. V√âRIFICATION CRITIQUE : G√©om√©trie ou coordonn√©es manquantes.
        // C'est ce bloc qui emp√™che l'erreur 'length'
        if (!featureFait || !featureFait.geometry || !featureFait.geometry.coordinates || featureFait.geometry.coordinates.length === 0) {
            console.warn(`Le fait ${faitNom} est ignor√© : g√©om√©trie ou coordonn√©es manquantes.`);
            return; // Passer √† la couche suivante
        }
        
        // --- Calcul du point de r√©f√©rence interne ---
        let pointFait;
        try {
            // Utiliser centerOfMass (g√®re les Multi-g√©om√©tries sans conversion manuelle risqu√©e)
            pointFait = turf.centerOfMass(featureFait);
        } catch (e) {
            // Fallback pour les g√©om√©tries complexes ou bris√©es
            try {
                pointFait = turf.pointOnFeature(featureFait);
            } catch (e2) {
                console.warn(`Impossible de calculer un point pour le fait ${faitNom} (g√©om√©trie corrompue).`, e2);
                return; // Passer √† la couche suivante si la g√©om√©trie est irr√©parable.
            }
        }
        
        // V√©rification de l'inclusion
        if (turf.booleanPointInPolygon(pointFait, buffer)) {
            faitsTrouves.push(faitNom);
        }
    });

    // --- Affichage et R√©sultat ---
    
    // Zoom visuel sur le tampon
    try {
        const tamponLayer = L.geoJson(buffer);
        map.fitBounds(tamponLayer.getBounds().pad(0.05));
    } catch {}

    if (faitsTrouves.length > 0) {
        const listeFaits = faitsTrouves.map(f => `&bull; <b>${f}</b>`).join('<br>');
        return `Dans un rayon de <b>${distanceMetres} m</b> autour de <b>${faitCentralNom}</b>, j‚Äôai trouv√© <b>${faitsTrouves.length}</b> autre(s) fait(s) :<br>${listeFaits}`;
    } else {
        return `Aucun autre fait arch√©ologique n‚Äôa √©t√© trouv√© dans un rayon de <b>${distanceMetres} m</b> autour de <b>${faitCentralNom}</b>.`;
    }
}


// --- Fonction pour calculer la PENTE entre deux faits ---
function calculerPente(faitA, faitB) {
    const layerA = getVestigeLayer(faitA);
    const layerB = getVestigeLayer(faitB);

    // V&eacute;rification des faits
    if (!layerA || !layerB) {
        // Corrections encodage
        return `?? Je n&rsquo;ai pas trouv&eacute; le fait ${!layerA ? faitA : faitB} sur la carte.`;
    }

    // 1. R&eacute;cup&eacute;ration de l'altitude
    const altA = FAIT_ALTIMETRY[faitA.toUpperCase()];
    const altB = FAIT_ALTIMETRY[faitB.toUpperCase()];

    // V&eacute;rification des donn&eacute;es Z
    if (altA === undefined || altB === undefined) {
        // Corrections encodage
        return `?? Les donn&eacute;es d'altitude (Z) sont incompl&egrave;tes pour le calcul de la pente entre ${faitA} et ${faitB}.`;
    }

    // 2. Calcul de la distance horizontale (XY)
    const centerA = turf.centroid(layerA.feature);
    const centerB = turf.centroid(layerB.feature);
    const distanceKm = turf.distance(centerA, centerB);
    const distanceMeters = distanceKm * 1000;

    // V&eacute;rification pour &eacute;viter la division par z&eacute;ro
    if (distanceMeters < 0.1) {
        // Corrections encodage
        return `Les faits <b>${faitA}</b> et <b>${faitB}</b> sont trop proches pour un calcul de pente significatif (distance : ${distanceMeters.toFixed(2)} m).`;
    }

    // 3. Calcul de la pente
    const differenceAltitude = altB - altA;
    const pentePourcent = (differenceAltitude / distanceMeters) * 100;

    // Mise en forme de la r&eacute;ponse
    const fmt = new Intl.NumberFormat('fr-FR', { maximumFractionDigits: 2 });
    let direction = "";
    
    if (pentePourcent > 0) {
        // Corrections encodage
        direction = ` (mont&eacute;e)`;
    } else if (pentePourcent < 0) {
        // Corrections encodage
        direction = ` (descente)`;
    } else {
        direction = ` (plat)`;
    }

    // Zoom sur l'emprise des deux points (pour l'utilisateur)
    const featureGroup = L.featureGroup([layerA, layerB]);
    map.fitBounds(featureGroup.getBounds().pad(0.05));

    // Corrections encodage
    return `
        <b>Analyse de la Pente entre ${faitA} et ${faitB} :</b><br>
        &bull; Diff&eacute;rence d'altitude : <b>${fmt.format(differenceAltitude)} m</b> (${altA.toFixed(2)} m vers ${altB.toFixed(2)} m).<br>
        &bull; Distance horizontale (XY) : <b>${fmt.format(distanceMeters)} m</b>.<br>
        &bull; Pente : <b>${fmt.format(pentePourcent)} %</b>${direction} (de ${faitA} vers ${faitB}).
    `;
}

// --- BASE DE CONNAISSANCES SIMUL√âE (Simule des milliers de r&eacute;ponses LLM) ---
const LOCAL_LLM_KNOWLEDGE = {
    // --- Salutations & Commandes ---
	// ... dans la fonction LOCAL_LLM_KNOWLEDGE ...

    // --- Salutations & Commandes (suite) ---
    // ... (vos entr√©es existantes, ex: "bonjour", "salut", "merci", etc.) ...
    
    // Nouvelle entr√©e de connaissance : Aide globale pour les commandes
    "aide": "Voici la liste des commandes g&eacute;ospatiales reconnues :<br><br>" +
                      "<b>1. Analyse de Fait (Fxx) :</b><br>" +
                      "&bull; Analyse compl&egrave;te : `F12`<br>" +
                      "&bull; Coordonn&eacute;es : `coordonn&eacute;es F12`<br>" +
                      "&bull; Parcelle : `parcelle F12`<br>" +
                      "&bull; Altitude : `altitude F12`<br><br>" +
                      "<b>2. Analyse Spatiale :</b><br>" +
                      "&bull; Distance : `distance entre F01 et F10`<br>" +
                      "&bull; Pente : `pente entre F05 et F03`<br>" +
                      "&bull; Rayon : `faits &agrave; 50 m de F12`<br>" +
                      "&bull; Parcelle : `liste des faits dans la parcelle B020`<br><br>",
                   

// ... suite de l'objet LOCAL_LLM_KNOWLEDGE ...
    "bonjour": "Bonjour ! Je suis votre assistant g&eacute;ospatial pour cette carte. Comment puis-je vous aider aujourd&rsquo;hui ?",
    "salut": "Salut ! Je suis pr&ecirc;t &agrave; analyser vos donn&eacute;es cartographiques. Posez-moi une question !",
    "merci": "De rien ! Je suis l&agrave; pour vous aider avec vos analyses g&eacute;ospatiales.",
    "localiser": "Utilisez la barre de recherche ou demandez-moi l&rsquo;analyse d&rsquo;un fait (ex: F12) pour le localiser. Je zoomerai automatiquement.",
    "question": "Posez des questions sur l'histoire (ex: 'villa romaine'), la g&eacute;ologie (ex: 'type de sol') ou le SIG (ex: 'Lambert 93').",
	"qui es tu": "Je suis un mod√®le d'IA Local l√©ger bas√© sur des biblioth√®ques JavaScript tr√®s r√©centes via WebGPU/WebAssembly. Mon code a √©t√© developp√© par Yahya. Il continue actuellement √† m'entrainer ;) pour √™tre plus performant.",

    // --- Th&egrave;mes Arch&eacute;ologie & Histoire Locale ---
    "villa romaine": "Une villa romaine &eacute;tait un grand domaine agricole et r&eacute;sidentiel. Elles &eacute;taient souvent divis&eacute;es en *pars urbana* (ma&icirc;tre) et *pars rustica* (ferme).",
    "thermes": "Les thermes &eacute;taient des &eacute;tablissements publics de bains. Ils jouaient un r&ocirc;le essentiel dans la vie sociale romaine, servant de lieux de d&eacute;tente et d'exercice.",
    "murus gallicus": "Le *murus gallicus* est un type de fortification celtique. Il est caract&eacute;ris&eacute; par des poutres en bois crois&eacute;es et fix&eacute;es par de longs clous en fer, le tout recouvert de pierres s&egrave;ches.",
    "c√©ramique sigill√©e": "La c&eacute;ramique sigill&eacute;e est une poterie romaine fine et rouge, souvent d&eacute;cor&eacute;e de motifs en relief. C'est une excellente source pour la datation.",
    "oppidum": "Un *oppidum* est un terme latin d&eacute;signant une place forte ou un habitat fortifi&eacute; de grande taille, typique de la p&eacute;riode gauloise finale (La T&egrave;ne).",
    "voie romaine": "Les voies romaines (ou *viae*) &eacute;taient des routes pav&eacute;es essentielles &agrave; la logistique militaire, au commerce et &agrave; l'administration de l'Empire.",
    "bas-empire": "Le Bas-Empire romain d&eacute;signe la p&eacute;riode tardive (IIIe au Ve si&egrave;cle ap. J.-C.), marqu&eacute;e par des r&eacute;formes et la mont&eacute;e du christianisme.",
    "moyen √¢ge": "Le Moyen &Acirc;ge est une p&eacute;riode historique allant du Ve si&egrave;cle (chute de l'Empire romain d'Occident) au XVe si&egrave;cle (Renaissance).",
    "ch√¢teau f√©odal": "Un ch&acirc;teau f&eacute;odal est une r&eacute;sidence fortifi&eacute;e construite par les seigneurs &agrave; partir du Xe si&egrave;cle pour contr&ocirc;ler le territoire.",
    "livron": "Livron-sur-Dr&ocirc;me a une histoire remontant &agrave; l'Antiquit&eacute;. C'est un carrefour fluvial et terrestre important. Les fouilles ont r&eacute;v&eacute;l&eacute; une occupation continue.",
    "antique": "La phase antique correspond &agrave; la p&eacute;riode romaine, environ de 50 avant J.-C. &agrave; 476 apr&egrave;s J.-C. dans cette r&eacute;gion. Le filtre permet de voir ces vestiges.",
    "medievale": "La phase m&eacute;di&eacute;vale couvre la p&eacute;riode qui s'&eacute;tend de la fin de l'Antiquit&eacute; (Ve si&egrave;cle) jusqu'&agrave; la Renaissance (XVe si&egrave;cle).",
    "aqueduc": "Les aqueducs &eacute;taient des ouvrages d'art romains con&ccedil;us pour acheminer l'eau des sources lointaines vers les villes (thermes, fontaines).",
    "mosa√Øque": "Les mosa&iuml;ques sont des ≈ìuvres d'art r&eacute;alis&eacute;es par l'assemblage de petits morceaux de pierre ou de verre (tesselles), typiques des sols de villas romaines luxueuses.",
    "gallo-romain": "Le terme gallo-romain d&eacute;signe la civilisation issue du m&eacute;lange des cultures gauloise et romaine apr&egrave;s la conqu&ecirc;te de la Gaule par C&eacute;sar.",

    // --- Th&egrave;mes G&eacute;ologiques & Environnementaux ---
    "type de sol": "L'analyse g&eacute;ologique r&eacute;v&egrave;le un sol compos&eacute; principalement d'alluvions fluviatiles de la Dr&ocirc;me et du Rh&ocirc;ne (galets, sables calcaires et siliceux).",
    "roche": "Les roches pr&eacute;dominantes dans la Dr&ocirc;me sont les calcaires du Vercors et les sables molassiques du bassin de Valence.",
    "dr√¥me rivi√®re": "La Dr&ocirc;me est une rivi&egrave;re affluent du Rh&ocirc;ne. Son cours a historiquement modifi&eacute; la morphologie de la plaine, impactant l'&eacute;tablissement des sites arch&eacute;ologiques.",
    "climat": "Le climat de la r&eacute;gion est de type m&eacute;diterran&eacute;en int&eacute;rioris&eacute; : &eacute;t&eacute;s chauds et secs, hivers relativement froids.",
    "s√©diments": "Les s&eacute;diments de la plaine sont principalement des limons et des argiles r&eacute;sultant des crues, qui ont contribu&eacute; &agrave; l'enfouissement et &agrave; la bonne conservation des vestiges.",
    
    // --- Th&egrave;mes Personnages C&eacute;l&egrave;bres ---
    "vercing√©torix": "Vercing&eacute;torix fut le chef de guerre gaulois qui mena la r&eacute;volte finale contre les arm&eacute;es de C&eacute;sar &agrave; Al&eacute;sia en -52 av. J.-C.",
    "jules c√©sar": "Jules C&eacute;sar &eacute;tait un g&eacute;n&eacute;ral et homme politique romain. Ses *Commentaires sur la Guerre des Gaules* sont une source cl&eacute; pour l'&eacute;tude de la Gaule.",
    "auguste": "Auguste, n&eacute; Octave, est le premier empereur romain. Son r&egrave;gne marque le d&eacute;but de la *Pax Romana* (stabilit&eacute; et prosp&eacute;rit&eacute;).",
    "charlemagne": "Charlemagne (roi des Francs et empereur) est une figure centrale du Haut Moyen &Acirc;ge (VIIIe-IXe si&egrave;cle).",
    "napol√©on": "Napol&eacute;on Bonaparte n'a pas de lien direct avec les vestiges antiques et m&eacute;di&eacute;vaux &eacute;tudi&eacute;s ici.",
    
    // --- Th&egrave;mes M&eacute;thodologie & SIG ---
    "carroyage": "Le carroyage arch&eacute;ologique est une m&eacute;thode de d&eacute;coupage d'un site en carr&eacute;s r&eacute;guliers pour localiser pr&eacute;cis&eacute;ment les objets et les structures en trois dimensions.",
    "sig": "SIG signifie Syst&egrave;me d'Information G&eacute;ographique. C'est un outil qui permet de g&eacute;rer, analyser et visualiser des donn&eacute;es g&eacute;or&eacute;f&eacute;renc&eacute;es, comme cette carte.",
    "lambert 93": "Le syst&egrave;me de projection Lambert 93 (EPSG:2154) est le syst&egrave;me l&eacute;gal de r&eacute;f&eacute;rence pour la cartographie et les donn&eacute;es g&eacute;ographiques en France m&eacute;tropolitaine.",
    "orthophoto": "Une orthophoto est une image a&eacute;rienne g&eacute;om&eacute;triquement corrig&eacute;e, qui a &eacute;t&eacute; redress&eacute;e pour &ecirc;tre utilisable comme un plan (elle n'a n'a pas les d&eacute;formations d'une photo simple).",
    "stratigraphie": "La stratigraphie est l'&eacute;tude de la superposition des couches (strates) de s&eacute;diments ou de vestiges. La couche la plus basse est la plus ancienne.",
    "cadastre": "Le cadastre est un registre public d&eacute;crivant et &eacute;valuant la propri&eacute;t&eacute; fonci&egrave;re, utilis&eacute; ici comme base pour localiser les faits dans les parcelles modernes.",
};

async function generateLocalAnswer(question) {
    // 1. Simuler un temps de chargement/calcul (WebGPU/WASM prend du temps)
    await new Promise(resolve => setTimeout(resolve, 1500)); // R&eacute;duit le temps &agrave; 1.5s
    
    // 2. Normalisation de la question pour la recherche (sans accents)
    const q = question.toLowerCase().trim()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, ''); 

    // 3. Recherche dans la base de connaissances simul&eacute;e
    for (const key in LOCAL_LLM_KNOWLEDGE) {
        // Normaliser la cl&eacute; du savoir pour une correspondance sans accent
        const normalizedKey = key.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');

        if (q.includes(normalizedKey)) {
            // Renvoyer la r&eacute;ponse d&eacute;taill&eacute;e trouv&eacute;e
            return LOCAL_LLM_KNOWLEDGE[key];
        }
    }

    // 4. R&eacute;ponse par d&eacute;faut si aucune commande spatiale ou connaissance g&eacute;n&eacute;rale n'a &eacute;t&eacute; trouv&eacute;e
    return "Je suis d&eacute;sol&eacute;, ma base de connaissances g&eacute;n&eacute;rales locale (simul&eacute;e) ne contient pas d'information sp&eacute;cifique sur ce sujet. Concentrez-vous sur les analyses g&eacute;ospatiales des faits (F12) et des parcelles (B020) !";
}


// --- Chatbot intelligent (LOGIQUE PRINCIPALE) ---
async function localAI(question) {
    const q = question.toLowerCase().trim();
    let response = null;
    let isSpatialQuery = false;
    
    // 0.5. COMMANDE NON SPATIALE : DATE ET HEURE ‚è∞
    if (q.includes("heure") || q.includes("date") || q.includes("jour") || q.includes("annee")) {
        return getFormattedDateTime();
    }
  // 1. V√âRIFICATION PRIORITAIRE : COMMANDE SPATIALE DANS UN RAYON (Correction de la Regex)
    // Elle est prioritaire sur toutes les analyses simples.
    const matchRayon = q.match(/faits\s+√†\s+(\d+)\s*m\s+de\s+([a-z0-9_-]+)/i);

    if (matchRayon) {
        const distance = parseInt(matchRayon[1]); // Doit capturer '50'
        const faitCentral = matchRayon[2].trim().toUpperCase(); // Doit capturer 'SP1033'
        
        console.log(`‚úÖ Commande Rayon d√©tect√©e: ${faitCentral}, ${distance}m.`);
        response = faitsDansRayon(faitCentral, distance);
        if (response) return response;
    }
   // 1. COMMANDE SPATIALE : DISTANCE ENTRE DEUX FAITS
const matchDistance = question.match(/distance\s+entre\s+([A-Za-z0-9._-]+)\s+et\s+([A-Za-z0-9._-]+)/i);
if (matchDistance) {
    const faitA = matchDistance[1].trim();
    const faitB = matchDistance[2].trim();
    return distanceEntreFaits(faitA, faitB);
}

    // 1.2. NOUVELLE COMMANDE SPATIALE : PENTE ENTRE DEUX FAITS ‚õ∞Ô∏è
    const matchPente = q.match(/(pente|d√©nivel√©)\s*(entre|de)\s*(fait|f)?\s*([a-z0-9_]+)\s*et\s*(fait|f)?\s*([a-z0-9_]+)/i);
    if (matchPente) {
        isSpatialQuery = true;
        response = calculerPente(matchPente[4], matchPente[6]);
    }

   

    // 2. NOUVELLE COMMANDE SPATIALE : ALTIM√âTRIE D'UN FAIT ‚õ∞Ô∏è
    const matchAltimetry = q.match(/(altitude|altimetrie|z|hauteur)\s*(du|de|pour)?\s*(fait|f)?\s*([a-z0-9_]+)/i);
    if (matchAltimetry && matchAltimetry[4]) {
        isSpatialQuery = true;
        const faitNom = matchAltimetry[4];
        response = getAltimetry(faitNom);
    }

   // 2.5. COMMANDE SPATIALE : LISTE DES FAITS DANS UNE PARCELLE (FIX : Priorit&eacute; donn&eacute;e et regex simplifi&eacute;e)
// L'ancienne regex est retir&eacute;e.
// La nouvelle regex cherche (liste/quels/trouve) suivi de n'importe quoi, puis "parcelle" et le num&eacute;ro.
const matchListeParcelle = q.match(/(liste|quels|trouve).*parcelle\s*([a-z0-9_]+)/i);

// 3. COMMANDE SPATIALE : ANALYSE D'UN SEUL FAIT
const matchFait = q.match(/(fait|f)\s*([a-z0-9_]+)/i);
const faitNom = matchFait ? matchFait[2] : null;

// Ex&eacute;cution en priorit&eacute; de la commande de liste de parcelle
if (matchListeParcelle && matchListeParcelle[2]) {
    isSpatialQuery = true;
    // Le num&eacute;ro de parcelle est d&eacute;sormais captur&eacute; dans le groupe [2]
    response = listerFaitsDansParcelle(matchListeParcelle[2]);
} 

// La commande 3 est maintenant un 'else if', et n'est ex&eacute;cut&eacute;e que si la parcelle n'a pas &eacute;t&eacute; d&eacute;tect&eacute;e.
else if (faitNom && getVestigeLayer(faitNom)) {
    isSpatialQuery = true;
    
    // Sous-commandes sp&eacute;cifiques &agrave; l'analyse
    if (q.includes("analyse") || q.includes("dimensions") || q.includes("coordonn&eacute;es")) response = analyserFait(faitNom);
    else if (q.includes("coordonn&eacute;e") || q.includes("lambert")) response = coordonneesLambert(faitNom);
    else if (q.includes("dimension") || q.includes("surface")) response = dimensionsFait(faitNom);
    else if (q.includes("parcelle")) response = parcelleFait(faitNom);
    else response = analyserFait(faitNom); // R&eacute;ponse par d&eacute;faut pour un fait connu
} else if (faitNom && !getVestigeLayer(faitNom)) {
     isSpatialQuery = true;
     response = `?? Je ne trouve pas d'entit&eacute; nomm&eacute;e &laquo; ${faitNom.toUpperCase()} &raquo; dans la couche des vestiges.`;
}
    
    // Si une r&eacute;ponse spatiale a &eacute;t&eacute; trouv&eacute;e, la retourner imm&eacute;diatement
    if (isSpatialQuery && response !== null) {
        return response;
    }
    
    // --- REPLI : RECHERCHE G&Eacute;N&Eacute;RALE (Simul&eacute;e) ---
    return await generateLocalAnswer(question);
}

// --- Interaction utilisateur (MISE &Agrave; JOUR ASYNCHRONE) ---
async function sendMessage() {
    const question = chatInput.value.trim();
    if (!question) return;
    
    // 1. Afficher la question de l'utilisateur
    appendMessage("&#128100; Toi", question);
    chatInput.value = "";
    
    // 2. Afficher un message d'attente
    appendMessage("&#129302; IA", "Recherche/Analyse en cours... ‚è≥"); 
    
    const lastMessage = chatLog.lastElementChild;
    let response;

    try {
        // 3. Appel asynchrone &agrave; localAI (g&egrave;re le temps de calcul pour la r&eacute;ponse g&eacute;n&eacute;rale)
        response = await localAI(question);
    } catch (e) {
        console.error("Erreur lors de l'appel &agrave; localAI :", e);
        response = "Une erreur technique est survenue lors du traitement de votre question.";
    }
    
    // 4. Remplacer le message d'attente par la r&eacute;ponse r&eacute;elle
    if (lastMessage) {
        lastMessage.innerHTML = `<b>&#129302; IA:</b> ${response}`;
    }
    chatLog.scrollTop = chatLog.scrollHeight;
}

chatSend.addEventListener('click', sendMessage);
chatInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendMessage(); });

// Message de bienvenue : il est maintenant affich&eacute; lors du premier clic sur l'ent&ecirc;te pour maintenir le chat r&eacute;duit au d&eacute;marrage.
map.whenReady(function() {
    // La bo&icirc;te est r&eacute;duite.
});
</script>

<script>
// =========================================================================
// --- LOGIQUE FILEMAKER (SYNCHRONISATION UNIDIRECTIONNELLE DES ATTRIBUTS) ---
// =========================================================================
const FM_URL = '/fm';
const FM_LAYOUT = 'Modapi';
const FM_USERNAME = 'Apia';
const FM_PASSWORD = 'Apia';
const FM_KEY_FIELD = 'fait';
let FM_TOKEN = null;
const POLLING_INTERVAL = 15000; // 15 s

// --- Authentification ---
async function getFileMakerToken() {
  if (FM_TOKEN) return FM_TOKEN;
  const authHeader = 'Basic ' + btoa(`${FM_USERNAME}:${FM_PASSWORD}`);
  try {
    const response = await fetch(`${FM_URL}/sessions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': authHeader }
    });
    if (!response.ok) throw new Error(`Erreur API: ${response.status}`);
    const data = await response.json();
    FM_TOKEN = data.response.token;
    console.log("‚úÖ Jeton FileMaker obtenu");
    return FM_TOKEN;
  } catch (e) {
    console.error("‚ùå Erreur d'authentification FileMaker:", e);
    return null;
  }
}

// --- Mise √† jour des propri√©t√©s des entit√©s ---
function updateFeatureProperties(currentFeature, fmRecord) {
  const f = fmRecord.fieldData;

  // Normalisation insensible √† la casse
  const phaseValue = f.Phase ?? f.phase ?? f.PHASE ?? null;
  const typeValue  = f.Type  ?? f.type  ?? f.TYPE  ?? null;
 
 // üí° Correction : Extraction des donn√©es MOBILIER C et MOBILIER F
  const mobilierCVal = f['Mobilier C'] ?? f['Mobilier_C'] ?? null; // Adapter le nom du champ FileMaker si n√©cessaire (ex: Mobilier_C)
  const mobilierFVal = f['Mobilier F'] ?? f['Mobilier_F'] ?? null;

  currentFeature.properties['Phase'] = phaseValue;
  currentFeature.properties['Type']  = typeValue;
  currentFeature.properties[FM_KEY_FIELD] = f[FM_KEY_FIELD];
  
  // üí° Correction : Application des donn√©es MOBILIER C et MOBILIER F
  currentFeature.properties['Mobilier C'] = mobilierCVal;
  currentFeature.properties['Mobilier F'] = mobilierFVal;
}


// --- Synchronisation des donn√©es FileMaker vers la carte ---
async function fetchAndSyncVestiges(token) {
  if (!token) return;
  try {
    const response = await fetch(`${FM_URL}/layouts/${FM_LAYOUT}/records`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }
    });

    if (response.status === 401) {
      console.warn("‚è≥ Jeton expir√©, reconnexion...");
      FM_TOKEN = null;
      const newToken = await getFileMakerToken();
      if (newToken) await fetchAndSyncVestiges(newToken);
      return;
    }

    if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`);
    const fmData = await response.json();
    const fmRecords = fmData.response.data;
    let matchCount = 0;

    // Parcours de chaque entit√© de la couche
layer_Vestiges_2.eachLayer(layer => {
  const currentFait = String(layer.feature.properties[FM_KEY_FIELD] || '').trim().toLowerCase();

  // Recherche tol√©rante : ignore casse et espaces
  const fmRecord = fmRecords.find(r =>
    String(r.fieldData[FM_KEY_FIELD] || '').trim().toLowerCase() === currentFait
  );

  if (fmRecord) {
    updateFeatureProperties(layer.feature, fmRecord);

    // Forcer la mise √† jour du popup
    const updatedPopup = `
      <table>
        <tr><th>FAIT</th><td>${layer.feature.properties['fait'] ?? ''}</td></tr>
        <tr><th>PHASE</th><td>${layer.feature.properties['Phase'] ?? ''}</td></tr>
        <tr><th>TYPE</th><td>${layer.feature.properties['Type'] ?? ''}</td></tr>
		<tr><th>MOBILIER C</th><td>${layer.feature.properties['Mobilier C'] ?? ''}</td></tr>
		<tr><th>MOBILIER F</th><td>${layer.feature.properties['Mobilier F'] ?? ''}</td></tr>
      </table>`;
    layer.bindPopup(updatedPopup, { maxHeight: 400 });
    if (layer.getPopup() && layer.getPopup().isOpen()) {
      layer.getPopup().setContent(updatedPopup);
    }

    matchCount++;
  } else {
    // Diagnostic console pour comprendre les cas manquants
    if (currentFait === 'SP1033') {
      console.warn('‚ö†Ô∏è Aucun enregistrement FileMaker correspondant pour SP1033');
    }
  }
});


    // üîÅ Actualisation du filtre "Phase"
    window.allVestiges = layer_Vestiges_2.toGeoJSON();
    filterVestiges();

    // 1. Remplir les menus d√©roulants avec les valeurs uniques
populateFilters(); 

// 2. Appliquer le filtre par d√©faut (qui est "Toutes") et mettre √† jour le compteur
filterVestiges(); 


    console.log(`‚úÖ FileMaker: ${matchCount} entit√©(s) mises √† jour.`);
  } catch (e) {
// ... (Fin de la fonction fetchAndSyncVestiges)
  }
}

// --- Polling stable avec verrouillage ---
let isSyncing = false;

map.whenReady(async function() {
  console.log("üîÑ D√©marrage du polling FileMaker stable...");

  const token = await getFileMakerToken();
  if (!token) return;

  // Premi√®re synchronisation
  await fetchAndSyncVestiges(token);

  // Intervalle r√©gulier (s√©curis√©)
  setInterval(async () => {
    if (isSyncing) return;
    isSyncing = true;
    try {
      const currentToken = await getFileMakerToken();
      await fetchAndSyncVestiges(currentToken);
    } catch (e) {
      console.error("Erreur pendant la synchro p√©riodique:", e);
    } finally {
      isSyncing = false;
    }
  }, POLLING_INTERVAL);
});
</script>
	<div id="coord-display" style="
    position:absolute; 
    bottom:10px; 
    right:400px; /* D√©plac√© √† gauche du Chatbot */
    z-index:9999; 
    background:rgba(255,255,255,0.85); 
    padding:4px 8px; 
    border-radius:4px; 
    font-family:monospace;
    font-size:12px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
">
    Coordonn√©es : 
</div>

<script>
/// ... (juste apr√®s la balise </script> du chatbot)

<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

<script>
// --- D√âFINITIONS DES SYST√àMES DE COORDONN√âES (Gardez votre code existant ici) ---
proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
proj4.defs("EPSG:3944", "+proj=lcc +lat_0=44 +lon_0=3 +lat_1=43.25 +lat_2=44.75 +x_0=1500000 +y_0=3200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
proj4.defs("EPSG:3945", "+proj=lcc +lat_0=45 +lon_0=3 +lat_1=44.25 +lat_2=45.75 +x_0=1700000 +y_0=4200000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
// ---------------------------------------------------------------------------------


// --- D√âBUT DU BLOC DE COORDONN√âES DE LA SOURIS (CORRIG√â) ---

// Variables pour le throttling : Limiter les calculs √† 5 fois par seconde (toutes les 200ms)
let lastCoordUpdate = 0;
const updateInterval = 200; 

const coordDisplay = document.getElementById('coord-display'); 

// ‚ö†Ô∏è CORRECTION CRITIQUE : Emp√™cher le conteneur de coordonn√©es de voler les clics.
if (coordDisplay) { 
    L.DomEvent.disableClickPropagation(coordDisplay); 
    L.DomEvent.disableScrollPropagation(coordDisplay); 
}

if (typeof proj4 === 'undefined') {
    if (coordDisplay) coordDisplay.innerHTML = "Erreur: proj4 non charg√©.";
} else {
    map.on('mousemove', function(e) {
        const now = Date.now();
        
        // --- LOGIQUE DE THROTTLING : N'ex√©cute le code qu'une fois toutes les 200ms ---
        if (now - lastCoordUpdate > updateInterval) {
            lastCoordUpdate = now;

            // --- CALCULS (Maintenant limit√©s en fr√©quence) ---

            // Coordonn√©es WGS 84 (Lat/Lon)
            const lat = e.latlng.lat.toFixed(6);
            const lon = e.latlng.lng.toFixed(6);

            // Conversion 1: Lambert 93 (EPSG:2154) - National
            const lambert93Coords = proj4('EPSG:4326', 'EPSG:2154', [e.latlng.lng, e.latlng.lat]);
            const lambert93X = lambert93Coords[0].toFixed(2);
            const lambert93Y = lambert93Coords[1].toFixed(2);
            
            // Conversion 2: Lambert CC44 (EPSG:3944) - Zone 4
            const cc44Coords = proj4('EPSG:4326', 'EPSG:3944', [e.latlng.lng, e.latlng.lat]);
            const cc44X = cc44Coords[0].toFixed(2);
            const cc44Y = cc44Coords[1].toFixed(2);
            
            // Conversion 3: Lambert CC45 (EPSG:3945) - Zone 5
            const cc45Coords = proj4('EPSG:4326', 'EPSG:3945', [e.latlng.lng, e.latlng.lat]);
            const cc45X = cc45Coords[0].toFixed(2);
            const cc45Y = cc45Coords[1].toFixed(2);

            // Mise √† jour du DOM
            if (coordDisplay) {
                coordDisplay.innerHTML = `
                    <span style="font-weight:bold;">WGS 84:</span> ${lat}¬∞ N, ${lon}¬∞ E<br>
                    <span style="font-weight:bold;">Lambert 93:</span> X=${lambert93X}, Y=${lambert93Y}<br>
                    <span style="font-weight:bold;">CC44:</span> X=${cc44X}, Y=${cc44Y}<br>
                    <span style="font-weight:bold;">CC45:</span> X=${cc45X}, Y=${cc45Y}
                `;
            }
        }
    });
}
// --- FIN DU BLOC DE COORDONN√âES DE LA SOURIS (CORRIG√â) ---
// ...
</script>


<div id="coord-display" style="
    position: absolute; 
    bottom: 25px; 
    left: 15px; 
    z-index: 9999; 
    background: rgba(255, 255, 255, 0.9); 
    padding: 5px 8px; 
    border-radius: 5px; 
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    font-family: Arial, sans-serif;
    font-size: 11px;
    line-height: 1.4;
">
    Livron, Les Renonc√©es Ouest
</div>
<script>
// ATTENTION : Ce code doit √™tre plac√© APR√àS le chargement des librairies Leaflet et la d√©finition de vos couches.

document.getElementById('downloadShpBtn').addEventListener('click', function() {
    let geojson;
    
    // 1. R√©cup√©ration de la couche Leaflet (filtr√©e en priorit√©, sinon la principale)
    if (window.layer_Vestiges_2_Filtered) {
        geojson = window.layer_Vestiges_2_Filtered.toGeoJSON();
    } else if (window.layer_Vestiges_2) {
        geojson = window.layer_Vestiges_2.toGeoJSON();
    } else {
        alert("Erreur : La couche 'layer_Vestiges_2' ou 'layer_Vestiges_2_Filtered' n'a pas √©t√© trouv√©e.");
        return;
    }

    // 2. V√©rification des donn√©es
    if (!geojson || !geojson.features || geojson.features.length === 0) {
        alert("Aucune entit√© (polygone, point, ligne) √† exporter n'a √©t√© trouv√©e.");
        return;
    }

    // 3. Conversion de l'objet GeoJSON en cha√Æne de caract√®res
    // L'argument '2' sert √† indenter le fichier pour une meilleure lisibilit√©.
    const geojsonString = JSON.stringify(geojson, null, 2); 
    
    // 4. Cr√©ation du Blob et du lien de t√©l√©chargement
    const jsonBlob = new Blob([geojsonString], { type: 'application/json' });
    const jsonUrl = URL.createObjectURL(jsonBlob);

    const a = document.createElement('a');
    a.href = jsonUrl;
    a.download = 'export_vestiges_brut.geojson'; // Nom du fichier t√©l√©charg√©
    document.body.appendChild(a);
    a.click();

    // 5. Nettoyage apr√®s le t√©l√©chargement
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(jsonUrl);
    }, 100);

    console.log(`‚úÖ Export GeoJSON r√©ussi avec ${geojson.features.length} entit√©s.`);
    alert(`Export GeoJSON brut r√©ussi. ${geojson.features.length} entit√©s ont √©t√© t√©l√©charg√©es dans 'export_vestiges_brut.geojson'.`);
});
</script>


</body>
</html>